var Lo = Object.defineProperty, Ao = Object.defineProperties;
var Zo = Object.getOwnPropertyDescriptors;
var ln = Object.getOwnPropertySymbols;
var Do = Object.prototype.hasOwnProperty, No = Object.prototype.propertyIsEnumerable;
var ae = Math.pow, cn = (e, t, n) => t in e ? Lo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, se = (e, t) => {
  for (var n in t || (t = {}))
    Do.call(t, n) && cn(e, n, t[n]);
  if (ln)
    for (var n of ln(t))
      No.call(t, n) && cn(e, n, t[n]);
  return e;
}, Xe = (e, t) => Ao(e, Zo(t));
var ye = (e, t, n) => new Promise((o, i) => {
  var s = (c) => {
    try {
      a(n.next(c));
    } catch (d) {
      i(d);
    }
  }, r = (c) => {
    try {
      a(n.throw(c));
    } catch (d) {
      i(d);
    }
  }, a = (c) => c.done ? o(c.value) : Promise.resolve(c.value).then(s, r);
  a((n = n.apply(e, t)).next());
});
import { isReactive as jo, reactive as Me, provide as $e, inject as Le, watch as U, toRef as Se, watchEffect as ve, computed as O, unref as M, ref as j, onMounted as Ue, onUnmounted as et, nextTick as jt, defineComponent as F, openBlock as S, createElementBlock as I, createBlock as W, resolveDynamicComponent as zn, createCommentVNode as ue, Fragment as G, renderList as J, mergeProps as oe, renderSlot as Y, normalizeClass as he, withModifiers as we, normalizeStyle as tt, useAttrs as Bo, createElementVNode as Tn, createTextVNode as Ro, toDisplayString as un, createVNode as je, withCtx as ne, useSlots as ht, createSlots as Bt, normalizeProps as _t, guardReactiveProps as It, TransitionGroup as Qe, toHandlers as Vo, readonly as qe } from "vue";
import { isEqual as Te, round as dn, merge as _n, mergeWith as Wo, isPlainObject as Ho, debounce as Fo, uniq as Uo, chunk as Rt } from "lodash-es";
const Xo = [
  "paths",
  "node-labels",
  "nodes",
  "focusring",
  "edge-labels",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
function ze(e) {
  return jo(e) ? e : Me(e);
}
function q(e, t = "Parameter") {
  if (e == null)
    throw new Error(`${t} is null`);
  return e;
}
const In = Symbol("containers");
function qo(e) {
  $e(In, e);
}
function Vt() {
  const e = q(Le(In), "containers");
  return {
    container: e.container,
    svg: e.svg,
    viewport: e.viewport,
    svgPanZoom: e.svgPanZoom
  };
}
class _ {
  static value(t, n) {
    return t instanceof Function ? t(n) : t;
  }
  static values(t, n) {
    return Object.values(t).filter((o) => o instanceof Function).length === 0 ? t : Object.fromEntries(
      Object.entries(t).map(([o, i]) => [o, i instanceof Function ? i(n) : i])
    );
  }
}
var D = /* @__PURE__ */ ((e) => (e.CENTER = "center", e.NORTH = "north", e.NORTH_EAST = "north-east", e.EAST = "east", e.SOUTH_EAST = "south-east", e.SOUTH = "south", e.SOUTH_WEST = "south-west", e.WEST = "west", e.NORTH_WEST = "north-west", e))(D || {});
function Mt(e) {
  const t = {};
  return Object.assign(t, e(t));
}
function Jr(e) {
  return e;
}
function ea(e) {
  return e;
}
function fn(e, t, n) {
  const o = _.values(t.normal, e);
  return o.type == "circle" ? {
    width: o.radius * 2 * n,
    height: o.radius * 2 * n
  } : {
    width: o.width * n,
    height: o.height * n
  };
}
function Go(e, t, n, o) {
  const s = Math.abs(e.x - n.x) < t.width / 2 + o.width / 2, a = Math.abs(e.y - n.y) < t.height / 2 + o.height / 2;
  return s && a;
}
function nt(e, t) {
  let n = 0;
  return t === 1 || e === void 0 || e === "none" ? n = e != null ? e : 0 : typeof e == "string" ? n = e.split(/\s+/).map((o) => parseInt(o) * t).filter((o) => !isNaN(o)).join(" ") : n = e * t, n && n !== "0" ? n : void 0;
}
function pt(e) {
  let t = 0;
  if (e === void 0 || e === "none")
    t = 0;
  else if (typeof e == "string") {
    const n = e.split(/\s+/).map((o) => parseInt(o)).filter((o) => !isNaN(o));
    n.length % 2 === 0 ? t = n.reduce((o, i) => o + i, 0) : t = n.reduce((o, i) => o + i, 0) * 2;
  } else
    t = e * 2;
  return t;
}
const hn = 20;
class $n {
  activate(t) {
    const { nodePositions: n, nodes: o, configs: i, emitter: s, scale: r, svgPanZoom: a } = t, c = (h) => {
      for (const [l, p] of Object.entries(h)) {
        const w = this.getOrCreateNodePosition(n, l);
        this.setNodePosition(w, p);
      }
    }, d = (h) => {
      const l = h.filter((k) => !(k in n.value)), p = a.getViewArea(), w = r.value;
      for (const k of l) {
        const y = o.value[k], v = fn(y, i.node, w), b = se({}, p.center);
        for (; ; ) {
          let g = !1;
          for (const [f, m] of Object.entries(n.value)) {
            if (k === f) continue;
            const x = o.value[f];
            if (!x) continue;
            const z = fn(x, i.node, w);
            if (g = Go(b, v, m, z), g)
              break;
          }
          if (g)
            b.x += v.width + hn * w, b.x + v.width / 2 > p.box.right && (b.x = p.center.x, b.y += v.height + hn * w);
          else
            break;
        }
        const E = this.getOrCreateNodePosition(n, k);
        this.setNodePosition(E, b);
      }
    };
    d(Object.keys(o.value));
    const u = U(
      () => Te(new Set(Object.keys(o.value)), new Set(Object.keys(n.value))),
      (h) => {
        h || d(Object.keys(o.value));
      }
    );
    s.on("node:dragstart", c), s.on("node:pointermove", c), s.on("node:dragend", c), this.onDeactivate = () => {
      u(), s.off("node:dragstart", c), s.off("node:pointermove", c), s.off("node:dragend", c);
    };
  }
  deactivate() {
    this.onDeactivate && this.onDeactivate();
  }
  setNodePosition(t, n) {
    t.value.x = dn(n.x, 3), t.value.y = dn(n.y, 3);
  }
  getOrCreateNodePosition(t, n) {
    const o = Se(t.value, n);
    return o.value || (o.value = { x: 0, y: 0 }), o;
  }
}
function Ln() {
  return {
    view: {
      scalingObjects: !1,
      panEnabled: !0,
      zoomEnabled: !0,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      doubleClickZoomEnabled: !0,
      mouseWheelZoomEnabled: !0,
      boxSelectionEnabled: !1,
      autoPanAndZoomOnLoad: "center-content",
      fitContentMargin: "8%",
      autoPanOnResize: !0,
      layoutHandler: new $n(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: !1,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      },
      selection: {
        box: {
          color: "#0000ff20",
          strokeWidth: 1,
          strokeColor: "#aaaaff",
          strokeDasharray: 0
        },
        detector: (e) => {
          const t = /Mac OS/.test(navigator.userAgent) ? e.metaKey : e.ctrlKey;
          return e.type === "keydown" ? t : !t;
        }
      },
      builtInLayerOrder: [],
      onBeforeInitialDisplay: void 0
    },
    node: Mt((e) => ({
      normal: {
        type: "circle",
        radius: 16,
        // for rect -->
        width: 32,
        height: 32,
        borderRadius: 4,
        // <-- for rect
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (t) => _.value(e.normal.type, t),
        radius: (t) => {
          var n;
          return ((n = _.value(e.normal.radius, t)) != null ? n : 0) + 2;
        },
        width: (t) => {
          var n;
          return ((n = _.value(e.normal.width, t)) != null ? n : 0) + 2;
        },
        height: (t) => {
          var n;
          return ((n = _.value(e.normal.height, t)) != null ? n : 0) + 2;
        },
        borderRadius: (t) => {
          var n;
          return (n = _.value(e.normal.borderRadius, t)) != null ? n : 0;
        },
        strokeWidth: (t) => _.value(e.normal.strokeWidth, t),
        strokeColor: (t) => _.value(e.normal.strokeColor, t),
        strokeDasharray: (t) => _.value(e.normal.strokeDasharray, t),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: !0,
      selectable: !1,
      label: {
        visible: !0,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        direction: D.SOUTH,
        directionAutoAdjustment: !1,
        text: "name",
        handleNodeEvents: !0
      },
      focusring: {
        visible: !0,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    })),
    edge: Mt((e) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: !1,
        animationSpeed: 50
      },
      hover: {
        width: (t) => _.value(e.normal.width, t) + 1,
        color: "#3355bb",
        dasharray: (t) => _.value(e.normal.dasharray, t),
        linecap: (t) => _.value(e.normal.linecap, t),
        animate: (t) => _.value(e.normal.animate, t),
        animationSpeed: (t) => _.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => _.value(e.normal.width, t) + 1,
        color: "#dd8800",
        dasharray: (t) => {
          const n = _.value(e.normal.width, t);
          return `${n * 1.5} ${n * 2}`;
        },
        linecap: (t) => _.value(e.normal.linecap, t),
        animate: (t) => _.value(e.normal.animate, t),
        animationSpeed: (t) => _.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (t, n) => n.edge.type == "curve" ? !1 : null,
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          // for circle -->
          radius: 6,
          // <-- for circle
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: !1,
          animationSpeed: 50
        }
      },
      selfLoop: {
        radius: 12,
        isClockwise: !0,
        offset: 10,
        angle: 270
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        padding: 4
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      }
    })),
    path: Mt((e) => ({
      visible: !1,
      clickable: !1,
      hoverable: !1,
      curveInNode: !1,
      end: "centerOfNode",
      margin: 0,
      // @Deprecated
      path: Me({
        width: 6,
        color: (t) => {
          const n = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ], o = t.edges.map(
            (i) => i.split("").reduce((s, r) => (s = (s << 5) - s + r.charCodeAt(0), s & s), 0)
          ).reduce((i, s) => i + s, 0);
          return n[Math.abs(o) % n.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: !1,
        animationSpeed: 50
      }),
      normal: {
        width: (t) => _.value(e.path.width, t),
        color: (t) => _.value(e.path.color, t),
        dasharray: (t) => _.value(e.path.dasharray, t),
        linecap: (t) => _.value(e.path.linecap, t),
        linejoin: (t) => _.value(e.path.linejoin, t),
        animate: (t) => _.value(e.path.animate, t),
        animationSpeed: (t) => _.value(e.path.animationSpeed, t)
      },
      hover: {
        width: (t) => _.value(e.normal.width, t) + 2,
        color: (t) => _.value(e.normal.color, t),
        dasharray: (t) => _.value(e.normal.dasharray, t),
        linecap: (t) => _.value(e.normal.linecap, t),
        linejoin: (t) => _.value(e.normal.linejoin, t),
        animate: (t) => _.value(e.normal.animate, t),
        animationSpeed: (t) => _.value(e.normal.animationSpeed, t)
      },
      selected: {
        width: (t) => _.value(e.normal.width, t) + 2,
        color: (t) => _.value(e.normal.color, t),
        dasharray: "6 12",
        linecap: (t) => _.value(e.normal.linecap, t),
        linejoin: (t) => _.value(e.normal.linejoin, t),
        animate: (t) => _.value(e.normal.animate, t),
        animationSpeed: (t) => _.value(e.normal.animationSpeed, t)
      },
      selectable: !1,
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    }))
  };
}
function ta(e) {
  const t = Ln();
  return e && _n(t, e), t;
}
const An = Symbol("style");
function Ko(e, t) {
  return Ho(e) ? _n(e, t) : t;
}
function Yo(e) {
  const t = Me(Ln()), n = Object.keys(t);
  for (const o of n)
    U(() => e.value[o], () => {
      Wo(t[o], e.value[o] || {}, Ko);
    }, { immediate: !0, deep: !0 });
  return $e(An, t), t;
}
function vt(e) {
  return q(Le(An), `Configs(${e})`)[e];
}
function Qo() {
  return vt("view");
}
function gt() {
  return vt("node");
}
function mt() {
  return vt("edge");
}
function Zn() {
  return vt("path");
}
let Jo = 1;
function ei() {
  return Jo++;
}
function fe(e) {
  return Object.entries(e);
}
function at(e, t) {
  const n = new Set(Object.keys(e));
  fe(t).forEach(([o, i]) => {
    Te(e[o], i) || (e[o] = i), n.delete(o);
  }), n.forEach((o) => delete e[o]);
}
function ti(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function ni(e, t, n) {
  const o = ze({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  return ve(() => {
    const { edgeLayoutPoints: i, edgeGroups: s } = ii(
      n,
      e.value,
      t.value
    );
    at(o.edgeLayoutPoints, i), at(o.edgeGroups, s);
  }), ve(() => {
    const i = {};
    for (const [s, { edges: r, groupWidth: a }] of Object.entries(o.edgeGroups)) {
      let c = !1;
      if (a == 0)
        c = !1;
      else if (n.edge.summarize instanceof Function) {
        const d = n.edge.summarize(r, n);
        d === null ? c = pn(e.value, r, n, a) : c = d;
      } else n.edge.summarize ? c = pn(e.value, r, n, a) : c = !1;
      o.edgeGroups[s].summarize = c, c && Object.keys(r).forEach((d) => i[d] = !0);
    }
    at(o.summarizedEdges, i);
  }), o;
}
function oi(e, t, n, o, i, s) {
  return e ? t ? vn(e.edge, n, o, i, 0, 0, s) : vn(
    e.edge,
    n,
    o,
    i,
    e.groupWidth,
    e.pointInGroup,
    s
  ) : { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } };
}
function ii(e, t, n) {
  const o = {}, i = {}, s = {};
  for (const [a, c] of Object.entries(n)) {
    if (!(c.source in t && c.target in t))
      continue;
    const d = [c.source, c.target].sort().join("<=>"), u = s[d] || {};
    u[a] = c, s[d] = u;
  }
  const r = e.edge.gap instanceof Function ? e.edge.gap : (a, c) => e.edge.gap;
  for (const [a, c] of Object.entries(s)) {
    const d = Object.keys(c).length;
    if (d == 0) continue;
    const u = r(c, e), [h, l] = Object.entries(c)[0];
    if (d === 1)
      o[h] = { edge: l, pointInGroup: 0, groupWidth: 0 }, i[a] = { edges: c, groupWidth: 0, summarize: !1 };
    else {
      let p = 0;
      const w = Object.entries(c).map(([v, b]) => {
        let E = _.value(e.edge.normal.width, b);
        return isNaN(+E) && (console.warn(
          "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
          v,
          E
        ), E = 1), E / 2;
      }), k = Object.entries(c).map(([v, b], E) => (E > 0 && (p += w[E - 1] + u + w[E]), [v, b, p])), y = p;
      k.forEach(([v, b, E]) => {
        o[v] = { edge: b, pointInGroup: E, groupWidth: y };
      }), i[a] = { edges: c, groupWidth: y, summarize: !1 };
    }
  }
  return { edgeLayoutPoints: o, edgeGroups: i };
}
function pn(e, t, n, o) {
  if (Object.entries(t).length === 1) return !1;
  const s = Math.min(
    ...Object.values(t).flatMap((r) => [e[r.source], e[r.target]]).filter((r) => r).map((r) => {
      const a = _.values(n.node.normal, r);
      return a.type === "circle" ? a.radius * 2 : Math.min(a.width, a.height);
    })
  );
  return o > s;
}
function vn(e, t, n, o, i, s, r) {
  var h, l, p, w, k, y, v, b;
  let a, c, d, u;
  return e.source < e.target ? [a, c, d, u] = gn(
    (h = t == null ? void 0 : t.x) != null ? h : 0,
    (l = t == null ? void 0 : t.y) != null ? l : 0,
    (p = n == null ? void 0 : n.x) != null ? p : 0,
    (w = n == null ? void 0 : n.y) != null ? w : 0,
    o,
    i,
    s,
    r
  ) : [d, u, a, c] = gn(
    (k = n == null ? void 0 : n.x) != null ? k : 0,
    (y = n == null ? void 0 : n.y) != null ? y : 0,
    (v = t == null ? void 0 : t.x) != null ? v : 0,
    (b = t == null ? void 0 : t.y) != null ? b : 0,
    o,
    i,
    s,
    r
  ), { p1: { x: a, y: c }, p2: { x: d, y: u } };
}
function gn(e, t, n, o, i, s, r, a) {
  const c = n - e, d = o - t;
  let u = (s / 2 - r) * i;
  if (u !== 0 && a !== "clock") {
    const h = Math.atan2(o - t, n - e);
    if (a === "vertical") {
      const l = Math.PI / 2;
      (h < -l || h >= l) && (u *= -1);
    } else a === "horizontal" && h < 0 && (u *= -1);
  }
  if (c === 0) {
    const h = d < 0 ? -1 : 1;
    return [e + u * h, t, n + u * h, o];
  } else if (d === 0) {
    const h = c < 0 ? 1 : -1;
    return [e, t + u * h, n, o + u * h];
  } else {
    const l = -1 / (d / c);
    d < 0 && (u = -u);
    const p = u / Math.sqrt(1 + Math.pow(l, 2));
    return [e + p, t + p * l, n + p, o + p * l];
  }
}
function Dn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x + t.x, n.y = e.y + t.y, n;
}
function Wt(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x - t.x, n.y = e.y - t.y, n;
}
function Nn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t.x, n.y = e.y * t.y, n;
}
function jn(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x * t, n.y = e.y * t, n;
}
function Ht(e, t, n) {
  return n || (n = { x: 0, y: 0 }), n.x = e.x / t.x, n.y = e.y / t.y, n;
}
function Bn(e, t) {
  return e.x * t.x + e.y * t.y;
}
function Rn(e, t) {
  return e.x * t.y - e.y * t.x;
}
function Ft(e) {
  return e.x * e.x + e.y * e.y;
}
function Ut(e) {
  return Math.sqrt(Ft(e));
}
function Xt(e, t) {
  const n = e.x - t.x, o = e.y - t.y;
  return n * n + o * o;
}
function Vn(e, t) {
  return Math.sqrt(Xt(e, t));
}
function Wn(e, t) {
  t || (t = { x: 0, y: 0 });
  const n = Ut(e);
  return n === 0 ? (t.x = 1, t.y = 0) : Ht(e, { x: n, y: n }, t), t;
}
function ct(e, t, n) {
  n || (n = { x: 0, y: 0 });
  const o = e.x * Math.cos(t) - e.y * Math.sin(t), i = e.x * Math.sin(t) + e.y * Math.cos(t);
  return n.x = o, n.y = i, n;
}
const si = 180 / Math.PI;
function ri(e) {
  return e * si;
}
function qt(e) {
  return Math.atan2(e.y, e.x);
}
function Gt(e) {
  return ri(qt(e));
}
const ai = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Dn,
  angle: qt,
  angleDegree: Gt,
  cross: Rn,
  distance: Vn,
  distanceSquared: Xt,
  divide: Ht,
  dot: Bn,
  length: Ut,
  lengthSquared: Ft,
  multiply: Nn,
  multiplyScalar: jn,
  normalize: Wn,
  rotate: ct,
  subtract: Wt
}, Symbol.toStringTag, { value: "Module" }));
class R {
  static fromArray(t) {
    return new R(t[0] || 0, t[1] || 0);
  }
  static fromObject(t) {
    return new R(t.x, t.y);
  }
  constructor(t, n) {
    this.x = t, this.y = n;
  }
  // instance methods
  add(t) {
    return Dn(this, t, this);
  }
  subtract(t) {
    return Wt(this, t, this);
  }
  multiply(t) {
    return Nn(this, t, this);
  }
  multiplyScalar(t) {
    return jn(this, t, this);
  }
  divide(t) {
    return Ht(this, t, this);
  }
  dot(t) {
    return Bn(this, t);
  }
  cross(t) {
    return Rn(this, t);
  }
  lengthSquared() {
    return Ft(this);
  }
  length() {
    return Ut(this);
  }
  distanceSquared(t) {
    return Xt(this, t);
  }
  distance(t) {
    return Vn(this, t);
  }
  normalize() {
    return Wn(this, this);
  }
  angle() {
    return qt(this);
  }
  angleDegree() {
    return Gt(this);
  }
  rotate(t) {
    return ct(this, t, this);
  }
  isEqualTo(t) {
    return this.x === t.x && this.y === t.y;
  }
  clone() {
    return new R(this.x, this.y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  toArray() {
    return [this.x, this.y];
  }
}
const ee = se({
  Vector2D: R
}, ai);
class Q {
  constructor(t, n, o) {
    this.source = t, this.target = n, this.v = o;
  }
  static fromLinePosition(t) {
    const n = R.fromObject(t.p1), o = R.fromObject(t.p2);
    return new Q(n, o, He(n, o));
  }
  static fromPositions(t, n) {
    const o = R.fromObject(t), i = R.fromObject(n);
    return new Q(o, i, He(o, i));
  }
  static fromVectors(t, n) {
    return new Q(t, n, He(t, n));
  }
}
function He(e, t) {
  return t.clone().subtract(e);
}
function li(e) {
  return [R.fromObject(e.p1), R.fromObject(e.p2)];
}
function ci(e) {
  return new R((e.p1.x + e.p2.x) / 2, (e.p1.y + e.p2.y) / 2);
}
function ut(e, t) {
  return { p1: e, p2: t };
}
function $t(e, t, n) {
  const o = Q.fromLinePosition(e);
  return ui(o, t, n);
}
function ui(e, t, n) {
  const o = e.v.clone().normalize(), i = e.source.clone().add(o.clone().multiplyScalar(t)), s = e.target.clone().subtract(o.clone().multiplyScalar(n));
  let r = i.toObject(), a = s.toObject();
  const c = He(i, s);
  if (e.v.angle() * c.angle() < 0) {
    const d = new R((r.x + a.x) / 2, (r.y + a.y) / 2), u = d.clone().add(o.multiplyScalar(0.5));
    r = d.toObject(), a = u.toObject();
  }
  return { p1: r, p2: a };
}
function di(e) {
  return { p1: e.p2, p2: e.p1 };
}
function Ge(e) {
  const t = e.v.clone().normalize().rotate(Math.PI / 2);
  return Q.fromVectors(e.target, e.target.clone().add(t));
}
function Kt(e, t) {
  const n = t.v.clone().normalize(), o = t.source, i = ee.subtract(e, o), s = n.dot(i);
  return o.clone().add(n.multiplyScalar(s));
}
function bt(e, t, n, o) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10))) return null;
  const r = Q.fromVectors(e, t), a = Kt(n, r), c = ee.length(ee.subtract(a, n));
  if (o < c) return null;
  if (o === c) return a;
  const d = Math.sqrt(ae(o, 2) - ae(c, 2)), u = r.v.normalize().multiplyScalar(d);
  return a.subtract(u);
}
function fi(e, t, n, o, i) {
  if (!(ee.lengthSquared(ee.subtract(t, n)) - o * o <= Math.pow(1, -10))) return null;
  const a = Q.fromVectors(e, t), c = Kt(n, a), d = ee.length(ee.subtract(c, n));
  if (o < d) return null;
  if (o === d) return c;
  const u = Math.sqrt(ae(o, 2) - ae(d, 2)), h = a.v.normalize().multiplyScalar(u), l = c.clone().add(h), p = c.clone().subtract(h), w = i.distance(l), k = i.distance(p);
  return Math.abs(w - k) < 2 ? p : w < k ? l : p;
}
function Ne(e, t) {
  const n = ee.subtract(t.source, e.source), o = e.v, i = t.v, s = ee.cross(n, o) / ee.cross(o, i);
  return t.source.clone().add(i.clone().multiplyScalar(s));
}
function Je(e, t, n, o, i) {
  const s = e, a = n.clone().subtract(s), c = a.length(), d = t + o;
  if (d < c) return null;
  const u = Math.abs(t - o);
  if (c < u) return null;
  if (c === d) {
    const m = a.clone().normalize(), x = e.clone().add(m.multiplyScalar(t));
    return i ? x : [x, x];
  }
  if (c === u) {
    const m = a.clone().normalize(), x = t > o, z = e.clone().add(m.multiplyScalar(x ? t : -t));
    return i ? z : [z, z];
  }
  const h = t, l = o, p = (ae(c, 2) + ae(h, 2) - ae(l, 2)) / (2 * c * h), w = h * p, k = Math.sqrt(ae(h, 2) - ae(w, 2)), y = a.clone().normalize(), v = new R(-y.y, y.x), b = y.clone().multiplyScalar(w), E = v.clone().multiplyScalar(k), g = e.clone().add(b).add(E), f = e.clone().add(b).subtract(E);
  if (i) {
    const m = g.distance(i), x = f.distance(i);
    return m < x ? g : f;
  } else
    return [g, f];
}
function mn(e, t, n, o) {
  const i = Q.fromPositions(e, t), s = (n.width + n.strokeWidth) / 2 * o, r = (n.height + n.strokeWidth) / 2 * o, a = n.borderRadius > 0 ? (n.borderRadius + n.strokeWidth / 2) * o : 0, c = (i.v.angle() - Math.PI / 2) % Math.PI, d = Math.PI / 2 - c % Math.PI, u = r * Math.abs(Math.tan(c)), h = s * Math.abs(Math.tan(d)), l = u <= s - a, p = h <= r - a;
  if (l || p || a === 0)
    return Math.sqrt(l ? ae(r, 2) + ae(u, 2) : ae(s, 2) + ae(h, 2));
  {
    const w = t.x - s + a, k = t.y - r + a, y = t.x + s - a, v = t.y + r - a, b = [
      new R(w, k),
      new R(y, k),
      new R(y, v),
      new R(w, v)
    ], E = Math.floor((i.v.angleDegree() + 360) % 360 / 90), g = b[E], f = bt(
      i.source,
      Kt(g, i),
      g,
      a
    );
    return f ? He(f, i.target).length() : He(g, i.target).length() + a;
  }
}
function Hn(e, t, n, o, i) {
  const s = Q.fromLinePosition(e), r = s.v.clone().normalize(), a = o === 0 ? s.source : s.source.clone().add(r.clone().multiplyScalar(o * i)), c = o === 0 ? s.target : s.target.clone().subtract(r.clone().multiplyScalar(o * i)), d = (t.width / 2 + n) * i, u = new R(-r.y, r.x).multiplyScalar(d);
  let h = ee.subtract(a, u), l = ee.add(a, u), p = ee.subtract(c, u), w = ee.add(c, u);
  const k = s.v.angleDegree();
  return (k < -90 || k >= 90) && ([h, l] = [l, h], [p, w] = [w, p]), {
    source: { above: h, below: l },
    target: { above: p, below: w }
  };
}
function hi(e, t, n, o) {
  let i;
  n.type === "circle" ? i = n.radius + n.strokeWidth / 2 : i = mn(
    t,
    e,
    n,
    1
    // scale
  );
  let s;
  return o.type === "circle" ? s = o.radius + o.strokeWidth / 2 : s = mn(
    e,
    t,
    o,
    1
    // scale
  ), [i, s];
}
function _e(e, t, n) {
  const { x: o, y: i } = e, s = o - t.x, r = i - t.y;
  return {
    x: s * Math.cos(n) - r * Math.sin(n) + t.x,
    y: s * Math.sin(n) + r * Math.cos(n) + t.y
  };
}
function Lt(e) {
  return e > 0 ? -(Math.PI * 2 - e) : Math.PI * 2 + e;
}
function At(e, t, n, o) {
  const i = [], s = Q.fromVectors(t, e), r = Q.fromVectors(t, n);
  let a = Fe(s, r);
  o * a < 0 && (a = Lt(a));
  const c = R.fromObject(_e(e, t, -a / 2)), d = Q.fromVectors(t, c), u = Ge(d), h = Fe(s, d);
  let l = Ge(s);
  if (Math.abs(h) < Math.PI / 2) {
    const w = Ne(l, u);
    i.push(w);
  } else {
    const w = R.fromObject(_e(c, t, h / 2)), k = Ge(
      Q.fromVectors(t, R.fromObject(w))
    ), y = Ne(l, k), v = Ne(k, u);
    i.push(y, w, v);
  }
  i.push(c);
  const p = Fe(r, d);
  if (l = Ge(r), Math.abs(p) < Math.PI / 2) {
    const w = Ne(l, u);
    i.push(w);
  } else {
    const w = R.fromObject(_e(c, t, p / 2)), k = Ge(
      Q.fromVectors(t, R.fromObject(w))
    ), y = Ne(u, k), v = Ne(k, l);
    i.push(y, w, v);
  }
  return i;
}
function Fe(e, t) {
  return Math.atan2(
    e.v.y * t.v.x - e.v.x * t.v.y,
    e.v.x * t.v.x + e.v.y * t.v.y
  );
}
function pi(e, t, n) {
  const o = e.x, i = e.y, s = t.x, r = t.y, a = n.x, c = n.y, d = o - s, u = i - r, h = a - s, l = c - r;
  if (d === 0 && u === 0 || h === 0 && l === 0)
    return [e, 0];
  const p = (l * (d * (o + s) + u * (i + r)) - u * (h * (a + s) + l * (c + r))) / (2 * d * l - 2 * u * h), w = (-h * (d * (o + s) + u * (i + r)) + d * (h * (a + s) + l * (c + r))) / (2 * d * l - 2 * u * h), k = Math.sqrt(Math.pow(o - p, 2) + Math.pow(i - w, 2));
  return [new R(p, w), k];
}
function We(e) {
  return e.type == "circle" ? e.radius : Math.min(e.width, e.height) / 2;
}
function vi(e) {
  const t = Object.values(e);
  if (t.length === 0)
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
  const n = {
    top: t[0].y,
    bottom: t[0].y,
    left: t[0].x,
    right: t[0].x
  };
  return t.forEach((o) => {
    n.top = Math.min(o.y, n.top), n.bottom = Math.max(o.y, n.bottom), n.left = Math.min(o.x, n.left), n.right = Math.max(o.x, n.right);
  }), n;
}
function it(...e) {
  return e.find((t) => !!t);
}
const gi = Number.EPSILON * 100;
function mi(e, t, n, o, i, s, r, a) {
  var k, y;
  const c = e.edges, d = e.directions, u = c.map((v, b) => yi(v, d[b], o[v.edgeId])), h = [];
  let l = !1, p = !1;
  {
    const v = u[0];
    let b = We(t[v.source].shape) * i;
    const E = a + (r === "edgeOfNode" ? b : 0), g = E <= 0 ? v.line.source : yn(v, E, n, !0);
    h.push(g), b = We(t[v.target].shape) * i, a > 0 && ee.distance(v.line.source, v.line.target) <= E + b && (l = !0);
  }
  const w = c.length;
  for (let v = 1; v < w; v++) {
    const b = u[v - 1], E = u[v], g = E.source, f = R.fromObject((k = n[g]) != null ? k : { x: 0, y: 0 }), m = bi(b, E, f), x = We(t[g].shape) * i, z = Math.max(x * (2 / 3), x - 4 * i), $ = Zt(b), C = Zt(E), T = st(b, f, z, $), L = st(E, f, z, !C), N = st(b, f, x, $), K = st(E, f, x, !C);
    let B;
    if (m) {
      const H = ee.distance(m, f);
      if (H < z)
        B = [
          it(T, N, b.line.target),
          m,
          it(L, K, E.line.source)
        ];
      else if (H <= x) {
        let me, le;
        N && T ? me = ee.distance(m, T) < ee.distance(m, N) ? T : N : me = N || b.line.target, K && L ? le = ee.distance(m, L) < ee.distance(m, K) ? L : K : le = K || E.line.source, B = [me, m, le];
      } else
        T && L ? B = [T, f, L] : N && K ? B = [N, f, K] : B = [
          it(T, N, b.line.target),
          f,
          it(L, K, E.line.source)
        ];
    } else
      T && L ? B = [T, f, L] : N && K ? B = [N, f, K] : B = [b.line.target, f, E.line.source];
    if (b.curve) {
      const H = h[h.length - 1];
      if (H) {
        const me = H instanceof Array ? H[H.length - 1] : H;
        let le;
        B instanceof Array ? le = s ? B[0] : B[1] : le = B;
        const Ee = At(
          me,
          b.curve.circle.center,
          le,
          b.curve.theta
        );
        B instanceof Array && s ? h.push([...Ee, ...B]) : h.push([...Ee, le]);
      }
    } else if (b.loop) {
      const [H, me, le] = En(f, b, x);
      h.push(H), h.push(le), B instanceof Array && s ? h.push([me, B[1], B[2]]) : h.push(B[2]);
    } else
      s || !(B instanceof Array) ? h.push(B) : E.curve ? h.push(B[1]) : E.loop ? h.push(B[0]) : h.push(B[0], B[2]);
  }
  {
    const v = u[u.length - 1];
    let b = We(t[v.target].shape) * i;
    const E = a + (r === "edgeOfNode" ? b : 0), g = E <= 0 ? v.line.target : yn(v, E, n, !1);
    if (b = We(t[v.source].shape) * i, v.loop) {
      const f = R.fromObject((y = n[v.target]) != null ? y : { x: 0, y: 0 }), [m, x, z] = En(f, v, b);
      h.push(m), h.push(z);
    } else if (v.curve) {
      const f = h[h.length - 1], m = f instanceof Array ? f[f.length - 1] : f, x = At(
        m,
        v.curve.circle.center,
        g,
        v.curve.theta
      );
      h.push([...x, g]);
    } else
      h.push(g);
    a > 0 && ee.distance(v.line.source, v.line.target) <= E + b && (p = !0);
  }
  return l && (h.shift(), h[0] instanceof Array && h.unshift(h[0][0])), p && h.pop(), h;
}
function bn(e) {
  const t = e.length;
  if (t === 0) return [];
  if (t <= 1) return [!0];
  const n = [];
  let o = null, i = !0;
  for (let s = 0; s < t; s++) {
    const r = e[s].edge.source, a = e[s].edge.target;
    if (s === 0)
      if (t > 2) {
        const c = Fn(e, 0);
        c === null ? i = !0 : i = c === a;
      } else
        i = [e[1].edge.source, e[1].edge.target].includes(a);
    else r === a ? i = !0 : i = o === r;
    n.push(i), o = i ? a : r;
  }
  return n;
}
function Fn(e, t) {
  const n = e[t], o = e[t + 1], i = [n.edge.source, n.edge.target].sort(), s = [o.edge.source, o.edge.target].sort();
  if (i[0] === i[1])
    return i[0];
  if (s[0] === s[1])
    return s[0];
  if (n.edgeId === o.edgeId || i[0] === s[0] && i[1] === s[1]) {
    if (t >= e.length - 2)
      return null;
    {
      const r = Fn(e, t + 1);
      return r === null ? null : r === i[1] ? i[0] : i[1];
    }
  } else
    return s.includes(i[1]) ? i[1] : i[0];
}
function yn(e, t, n, o) {
  const i = o ? e.source : e.target, s = e.curve;
  if (s) {
    let r = t / s.circle.radius;
    return s.theta > 0 && (r *= -1), o || (r *= -1), R.fromObject(
      _e(
        o ? e.line.source : e.line.target,
        s.circle.center,
        r
      )
    );
  } else {
    let r, a;
    if (o ? (r = e.line.target, a = e.line.source) : (r = e.line.source, a = e.line.target), n[i]) {
      const c = bt(
        r,
        a,
        R.fromObject(n[i]),
        t
      );
      return c === null ? r : c;
    } else
      return r;
  }
}
function bi(e, t, n) {
  let o = null;
  if (e.loop || t.loop)
    o = null;
  else if (e.curve)
    if (t.curve) {
      if (e.line.target.isEqualTo(t.line.source))
        return e.line.target.clone();
      o = Je(
        e.curve.circle.center,
        e.curve.circle.radius,
        t.curve.circle.center,
        t.curve.circle.radius,
        e.curve.center
      );
    } else
      o = fi(
        t.line.target,
        t.line.source,
        e.curve.circle.center,
        e.curve.circle.radius,
        n
      );
  else if (t.curve)
    o = bt(
      e.line.source,
      e.line.target,
      t.curve.circle.center,
      t.curve.circle.radius
    );
  else {
    const i = wn(e.line), s = wn(t.line);
    !isFinite(i) && !isFinite(s) || Math.abs(i - s) < gi ? o = null : o = Ne(e.line, t.line);
  }
  return o;
}
function st(e, t, n, o) {
  if (e.loop) {
    const i = Je(
      t,
      n,
      e.loop.center,
      e.loop.radius[0]
    );
    return i ? o ? i[0] : i[1] : null;
  } else return e.curve ? Je(
    t,
    n,
    e.curve.circle.center,
    e.curve.circle.radius,
    R.fromObject(e.curve.center)
  ) : bt(
    o ? e.line.source : e.line.target,
    o ? e.line.target : e.line.source,
    t,
    n
  );
}
function yi(e, t, n) {
  let o = n.origin, i = e.edge.source, s = e.edge.target, r = n.curve;
  const a = n.loop;
  a ? o = n.position : t || (o = di(o), i = e.edge.target, s = e.edge.source, r && (r = Xe(se({}, r), { theta: -r.theta })));
  const c = Q.fromLinePosition(o);
  return {
    edgeId: e.edgeId,
    source: i,
    target: s,
    line: c,
    direction: t,
    curve: r,
    loop: a
  };
}
function wn(e) {
  return (e.target.y - e.source.y) / (e.target.x - e.source.x);
}
function En(e, t, n) {
  const { radius: o, center: i } = q(t.loop, "Loop of edge parameter"), [s, r] = o, a = Je(e, n, i, o[0]);
  let [c, d] = a ? a.reverse() : [t.line.source, t.line.target];
  const u = Zt(t);
  u || ([c, d] = [d, c]);
  const h = c, l = d, p = R.fromObject(h).subtract(i).angleDegree();
  let y = (R.fromObject(l).subtract(i).angleDegree() + 360 - p) % 360 >= 180;
  return y = u ? y : !y, [h, l, `A ${s} ${r} 0 ${y ? 1 : 0} ${u ? 1 : 0} ${l.x} ${l.y}`];
}
function Zt(e) {
  return e.loop ? e.direction ? e.loop.isClockwise : !e.loop.isClockwise : !0;
}
function Ct(e, t, n, o, i, s, r) {
  const a = Me({});
  U(
    () => new Set(Object.keys(e.value)),
    (d, u) => {
      u || (u = /* @__PURE__ */ new Set([]));
      for (const h of d)
        u.has(h) || wi(e, a, h, !1, t, i);
      for (const h of u)
        d.has(h) || (n.delete(h), o.delete(h), s == null || s(h, a[h]), delete a[h]);
    },
    { immediate: !0 }
  ), U(
    () => [...n],
    (d, u) => {
      const h = u ? d.filter((p) => !u.includes(p)) : d, l = u ? u.filter((p) => !d.includes(p)) : [];
      h.forEach((p) => {
        const w = a[p];
        w && !w.selected && (w.selected = !0);
      }), l.forEach((p) => {
        const w = a[p];
        w && w.selected && (w.selected = !1);
      });
    },
    { immediate: !0 }
    // for specified from the beginning
  ), U(
    () => [...o],
    (d, u) => {
      const h = d.filter((p) => !u.includes(p)), l = u.filter((p) => !d.includes(p));
      h.forEach((p) => {
        const w = a[p];
        w && !w.hovered && (w.hovered = !0);
      }), l.forEach((p) => {
        const w = a[p];
        w && w.hovered && (w.hovered = !1);
      });
    }
  );
  const c = O(() => {
    const d = r ? r() : Object.values(a);
    return t.zOrder.enabled ? Ei(d, t.zOrder, o, n) : d;
  });
  return { states: a, zOrderedList: c };
}
function wi(e, t, n, o, i, s) {
  const r = {
    id: n,
    selected: o,
    hovered: !1,
    selectable: O(() => e.value[n] ? _.value(i.selectable, e.value[n]) : M(r.selectable)),
    zIndex: O(() => e.value[n] ? _.value(i.zOrder.zIndex, e.value[n]) : M(r.zIndex))
  };
  t[n] = r, s(
    e,
    n,
    t[n]
    /* get reactive object */
  );
}
function Ei(e, t, n, o) {
  return t.bringToFrontOnHover && t.bringToFrontOnSelected ? e.sort((i, s) => {
    const r = n.has(i.id), a = n.has(s.id);
    if (r != a)
      return r ? 1 : -1;
    const c = o.has(i.id), d = o.has(s.id);
    return c != d ? c ? 1 : -1 : i.zIndex - s.zIndex;
  }) : t.bringToFrontOnHover ? e.sort((i, s) => {
    const r = n.has(i.id), a = n.has(s.id);
    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;
  }) : t.bringToFrontOnSelected ? e.sort((i, s) => {
    const r = o.has(i.id), a = o.has(s.id);
    return r != a ? r ? 1 : -1 : i.zIndex - s.zIndex;
  }) : e.sort((i, s) => i.zIndex - s.zIndex);
}
function ki(e) {
  return typeof btoa === void 0 ? Buffer.from(e).toString("base64").replaceAll("=", "") : btoa(e).replaceAll("=", "");
}
function xi() {
  return { markers: Me({}), referenceCount: {} };
}
function Pi(e) {
  const { markers: t, referenceCount: n } = e;
  function o(a, c) {
    var u;
    const d = (u = n[a]) != null ? u : 0;
    n[a] = d + 1, d || (t[a] = c);
  }
  function i(a) {
    var d;
    const c = (d = n[a]) != null ? d : 0;
    c && (c - 1 === 0 ? (delete t[a], delete n[a]) : n[a] = c - 1);
  }
  function s(a) {
    a && i(a);
  }
  function r(a, c, d, u, h) {
    if (a.type === "none") {
      s(d);
      return;
    }
    if (a.type === "custom")
      return s(d), a.customId;
    const l = Si(a, c, u), p = Mi(l, h);
    return p === d || (s(d), o(p, l)), p;
  }
  return {
    makeMarker: r,
    clearMarker: s
  };
}
function Si(e, t, n) {
  var o;
  return Xe(se({}, e), {
    color: (o = e.color) != null ? o : n,
    isSource: t
  });
}
function Mi(e, t) {
  const n = ki(e.color), o = e.isSource ? "L" : "R", i = e.units === "strokeWidth" ? "rel" : "abs";
  return `marker_${t}_${e.type}_${e.width}_${e.height}_${e.margin}_${e.offset}_${n}_${o}_${i}`;
}
function Ot(e, t, n) {
  return {
    objects: e,
    selected: t,
    hovered: n
  };
}
const Un = Symbol("states"), Ci = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  offset: 0,
  units: "strokeWidth",
  color: null
};
function Oi(e, t, n, o, i, s, r, a) {
  const c = Me({}), d = ze({});
  ve(() => {
    const g = Object.fromEntries(
      Object.keys(e.objects.value).map((f) => [f, {}])
    );
    Object.entries(t.objects.value).forEach(([f, m]) => {
      g != null && g[m.source] || (g[m.source] = {}), g != null && g[m.target] || (g[m.target] = {}), g[m.source][f] = m.target, g[m.target][f] = m.source;
    }), at(d, g);
  });
  const {
    states: u,
    zOrderedList: h
    //
  } = Ct(
    e.objects,
    o.node,
    e.selected,
    e.hovered,
    (g, f, m) => {
      _i(
        g,
        f,
        m,
        o.node,
        d,
        i,
        s
      );
    },
    (g, f) => {
      const m = i.nodes;
      delete m[g];
    }
  ), l = ei(), p = ni(e.objects, t.objects, o), w = j([]), {
    states: k,
    zOrderedList: y
    //
  } = Ct(
    t.objects,
    o.edge,
    t.selected,
    t.hovered,
    (g, f, m) => {
      $i(
        g,
        f,
        m,
        o.edge,
        r,
        u,
        p,
        i,
        a,
        l
      );
    },
    (g, f) => {
      var m;
      (m = f.stopWatchHandle) == null || m.call(f);
    },
    () => w.value
  );
  ve(() => {
    w.value = Li(p.edgeGroups, k);
  }), U(
    p.edgeGroups,
    (g) => Di(c, p, o),
    { immediate: !0 }
  );
  const {
    states: v,
    zOrderedList: b
    //
  } = Ct(
    n.objects,
    o.path,
    n.selected,
    n.hovered,
    (g, f, m) => {
      const x = m;
      x.clickable = O(() => g.value[f] ? _.value(o.path.clickable, g.value[f]) : !1), x.hoverable = O(() => g.value[f] ? _.value(o.path.hoverable, g.value[f]) : !1), x.path = g.value[f], x.edges = xn(x.path, t), x.directions = bn(x.edges), x.stopWatchHandle = U(
        () => g.value[f].edges,
        () => {
          x.path = g.value[f], x.edges = xn(x.path, t), x.directions = bn(x.edges);
        }
      );
    },
    (g, f) => {
      var m;
      (m = f.stopWatchHandle) == null || m.call(f);
    }
  ), E = {
    nodeStates: u,
    edgeStates: k,
    edgeGroupStates: p,
    summarizedEdgeStates: c,
    pathStates: v,
    layouts: i,
    nodeZOrderedList: h,
    edgeZOrderedList: y,
    pathZOrderedList: b
  };
  return $e(Un, E), E;
}
function zi(e) {
  return e.summarized;
}
function ke() {
  return q(Le(Un), "states");
}
function Ti(e, t, n, o) {
  return n && o.hover ? _.values(o.hover, e) : Xn(e, t, o);
}
function Xn(e, t, n) {
  return t && n.selected ? _.values(n.selected, e) : _.values(n.normal, e);
}
function _i(e, t, n, o, i, s, r) {
  var a, c;
  !s.nodes[t] && ((a = r.nodes) != null && a[t]) && (s.nodes[t] = se({}, (c = r.nodes) == null ? void 0 : c[t])), n.shape = O(() => e.value[t] ? Ti(e.value[t], n.selected, n.hovered, o) : M(n.shape)), n.staticShape = O(() => e.value[t] ? Xn(e.value[t], n.selected, o) : M(n.staticShape)), n.label = O(() => e.value[t] ? _.values(o.label, e.value[t]) : M(n.label)), n.labelText = O(() => {
    var d, u;
    return o.label.text instanceof Function ? M(n.label).text : e.value[t] ? (u = (d = e.value[t]) == null ? void 0 : d[M(n.label).text]) != null ? u : "" : M(n.labelText);
  }), n.draggable = O(() => e.value[t] ? _.value(o.draggable, e.value[t]) : M(n.draggable)), n.oppositeNodeIds = Se(i, t), n.oppositeNodes = O(() => Object.entries(n.oppositeNodeIds).reduce(
    (d, u) => {
      const [h, l] = u, p = s.nodes[l];
      return p && (d[h] = { nodeId: l, pos: se({}, p) }), d;
    },
    {}
  ));
}
function Ii(e, t, n, o) {
  return t ? _.values(o.selected, e) : n && o.hover ? _.values(o.hover, e) : _.values(o.normal, e);
}
function kn(e) {
  return e.type === "none" ? Ci : e;
}
function $i(e, t, n, o, i, s, r, a, c, d) {
  const { makeMarker: u, clearMarker: h } = Pi(i);
  Object.assign(n, {
    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }
  }), n.label = O(() => e.value[t] ? _.values(o.label, e.value[t]) : M(n.label));
  const l = O(() => {
    const v = e.value[t], b = Ii(v, n.selected, n.hovered, o);
    isNaN(+b.width) && (console.warn(
      "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
      t,
      b.width
    ), b.width = 1), (b.color === void 0 || b.color === null) && (console.warn(
      "[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]",
      t,
      b.color
    ), b.color = "#000000");
    let E = _.value(o.normal.width, v);
    isNaN(+E) && (E = 1);
    const g = kn(_.values(o.marker.source, [v, b])), f = kn(_.values(o.marker.target, [v, b]));
    return { stroke: b, normalWidth: E, source: g, target: f };
  });
  n.line = l;
  const p = Se(
    r.edgeLayoutPoints,
    t
  ), w = Se(r.summarizedEdges, t), k = ve(() => {
    var B, H, me, le, Ee, Ae, Ze;
    const v = e.value[t];
    if (!v) return;
    const b = (B = s[v.source]) == null ? void 0 : B.staticShape, E = (H = s[v.target]) == null ? void 0 : H.staticShape;
    if (!b || !E)
      return;
    const g = (me = a.nodes[v == null ? void 0 : v.source]) != null ? me : { x: 0, y: 0 }, f = (le = a.nodes[v == null ? void 0 : v.target]) != null ? le : { x: 0, y: 0 }, m = oi(
      p.value,
      (Ee = w.value) != null ? Ee : !1,
      g,
      f,
      c.value,
      o.keepOrder
    ), [x, z] = hi(g, f, b, E), $ = c.value;
    n.labelPosition = $t(
      m,
      x * $,
      z * $
    );
    let C = 0, T = 0;
    const L = l.value;
    if (L.source.type !== "none") {
      const ce = L.source;
      C = ce.margin + ce.width, ce.units === "strokeWidth" && (C *= L.normalWidth);
    }
    if (L.target.type !== "none") {
      const ce = L.target;
      T = ce.margin + ce.width, ce.units === "strokeWidth" && (T *= L.normalWidth);
    }
    o.margin && (C += o.margin, T += o.margin);
    const N = !!o.margin || L.source.type !== "none" || L.target.type !== "none";
    if (v.source === v.target) {
      n.origin = ut(g, f);
      const ce = _.values(o.selfLoop, v), [Be, Re] = Zi(
        g,
        b,
        ce,
        N,
        C,
        T,
        (Ze = (Ae = p.value) == null ? void 0 : Ae.pointInGroup) != null ? Ze : 0,
        $
      );
      n.position = Be, n.loop = Re, n.curve = void 0;
      return;
    } else
      n.loop = void 0;
    if (N && (C += x, T += z), o.type === "straight" || w.value)
      n.origin = m, n.curve = void 0, C === 0 && T === 0 ? n.position = n.origin : n.position = $t(n.origin, C * $, T * $);
    else {
      n.origin = ut(g, f);
      const ce = p.value ? p.value.groupWidth / 2 - p.value.pointInGroup : 0, [Be, Re] = Ai(
        n.origin,
        m,
        ce,
        C * $,
        T * $
      );
      n.position = Be, n.curve = Re;
    }
  }), y = ve(() => {
    e.value[t] && (n.sourceMarkerId = u(
      l.value.source,
      !0,
      n.sourceMarkerId,
      l.value.stroke.color,
      d
    ), n.targetMarkerId = u(
      l.value.target,
      !1,
      n.targetMarkerId,
      l.value.stroke.color,
      d
    ));
  });
  n.stopWatchHandle = () => {
    k(), y(), h(n.sourceMarkerId), h(n.targetMarkerId);
  };
}
function Li(e, t) {
  return Object.entries(e).map(([n, o]) => {
    var i;
    return o.summarize ? {
      id: (i = Object.keys(o.edges)[0]) != null ? i : n,
      summarized: !0,
      key: n,
      group: o,
      zIndex: Object.keys(o.edges).map((s) => {
        var r, a;
        return (a = (r = t[s]) == null ? void 0 : r.zIndex) != null ? a : 0;
      }).reduce((s, r) => Math.max(s, r))
    } : Object.entries(o.edges).map(
      ([s, r]) => {
        var a, c;
        return {
          id: s,
          summarized: !1,
          key: s,
          edge: r,
          zIndex: (c = (a = t[s]) == null ? void 0 : a.zIndex) != null ? c : 0
        };
      }
    );
  }).flat();
}
function Ai(e, t, n, o, i) {
  const s = Q.fromLinePosition(e), r = Q.fromLinePosition(t), a = ci(t), [c, d] = pi(
    s.source,
    s.target,
    a
  );
  let u, h;
  if (d === 0)
    return [e, h];
  if (n === 0)
    return o === 0 && i === 0 ? u = e : u = $t(e, o, i), [u, h];
  const l = Q.fromVectors(c, a), p = Fe(
    Q.fromVectors(c, s.source),
    l
  );
  if (o === 0 && i === 0)
    u = e;
  else {
    let v = o / d, b = i / d;
    p > 0 && (v *= -1, b *= -1), u = ut(
      _e(s.source, c, v),
      _e(s.target, c, -b)
    );
    let E = Fe(
      Q.fromVectors(c, s.source),
      Q.fromVectors(c, s.target)
    ), g = Fe(
      Q.fromPositions(c, u.p1),
      Q.fromPositions(c, u.p2)
    );
    if (p * E < 0 && (E = Lt(E), p * g < 0 && (g = Lt(g))), E * g < 0) {
      const f = a.clone().add(r.v.normalize().multiplyScalar(0.5));
      return u = ut(a, f), [u, h];
    }
  }
  const [w, k] = li(u), y = At(w, c, k, p).map((v) => v.toObject());
  return h = {
    center: a,
    theta: p,
    circle: { center: c, radius: d },
    control: y
  }, [u, h];
}
function Zi(e, t, n, o, i, s, r, a) {
  const c = a, d = (n.radius + r / 2) * c, u = n.offset * c + d, h = (n.angle - 90) * (Math.PI / 180), l = R.fromObject({
    x: e.x + u * Math.cos(h),
    y: e.y + u * Math.sin(h)
  }), p = n.isClockwise;
  let w, k;
  if (o) {
    const g = Je(
      l,
      d,
      R.fromObject(e),
      We(t) * c
    );
    if (g) {
      [w, k] = g;
      let f = 1;
      if (p || ([w, k] = [k, w], f = -1), i !== 0 || s !== 0) {
        const m = i * c / d * f, x = s * c / d * f;
        w = _e(w, l, m), k = _e(k, l, -x);
      }
    }
  }
  if (w === void 0 || k === void 0) {
    const g = R.fromObject(e).subtract(l).normalize().multiplyScalar(d);
    let f = 1 * (Math.PI / 180);
    p || (f *= -1), w = l.clone().add(ct(g, f)), k = l.clone().add(ct(g, -f));
  }
  const y = R.fromObject(w).subtract(l).angleDegree(), E = (R.fromObject(k).subtract(l).angleDegree() + 360 - y) % 360 >= 180;
  return [
    { p1: w, p2: k },
    {
      center: l,
      radius: [d, d],
      isLargeArc: p ? E : !E,
      isClockwise: p
    }
  ];
}
function Di(e, t, n) {
  const o = t.edgeGroups;
  Object.entries(o).filter(([i, s]) => s.summarize && !(i in e)).forEach(([i, s]) => {
    const r = { stroke: void 0 };
    r.stroke = O(
      () => _.values(n.edge.summarized.stroke, s.edges)
    ), e[i] = r;
  }), Object.keys(e).forEach((i) => {
    var s;
    (s = t.edgeGroups[i]) != null && s.summarize || delete e[i];
  });
}
function xn(e, t) {
  return e.edges.map((n) => ({ edgeId: n, edge: t.objects.value[n] })).filter((n) => n.edge);
}
class Ye {
  static valueOf(t) {
    return Array.from(t.values());
  }
}
const Ni = 3, ji = 6, qn = 500;
function lt(e) {
  return e === "touch" ? ji : Ni;
}
function Yt(e, t, n, o) {
  let i = e.get(t);
  if (i)
    i.id !== n && (i = void 0);
  else {
    const a = Array.from(e.entries()).find(([c, d]) => d.id === n);
    if (a) {
      const [c, d] = a;
      e.delete(c), i = d;
    }
  }
  let s, r;
  return [i, s, r] = Gn(i, o, n), e.set(t, i), [s, r];
}
function Gn(e, t, n) {
  const o = Date.now();
  e && o - e.lastTime <= qn ? (e.count++, e.lastTime = o) : e = { count: 1, lastTime: o, id: n };
  const i = {
    view: window,
    screenX: t.screenX,
    screenY: t.screenY,
    clientX: t.clientX,
    clientY: t.clientY,
    ctrlKey: t.ctrlKey,
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    metaKey: t.metaKey,
    button: t.button,
    buttons: t.buttons,
    detail: e.count
  };
  let s, r;
  return t instanceof PointerEvent ? (Object.assign(i, {
    pointerId: t.pointerId,
    width: t.width,
    height: t.height,
    pressure: t.pressure,
    tangentialPressure: t.tangentialPressure,
    tiltX: t.tiltX,
    tiltY: t.tiltY,
    twist: t.twist,
    pointerType: t.pointerType,
    isPrimary: t.isPrimary
  }), s = new PointerEvent("click", i), e.count === 2 && (r = new PointerEvent("dblclick", i))) : (s = new MouseEvent("click", i), e.count === 2 && (r = new MouseEvent("dblclick", i))), [e, s, r];
}
function Qt(e) {
  const t = Date.now();
  Array.from(e.entries()).filter(([n, o]) => t - o.lastTime > qn).map(([n, o]) => e.delete(n));
}
function Bi(e, t, n, o, i, s, r) {
  const a = {
    pointers: /* @__PURE__ */ new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodesPre: /* @__PURE__ */ new Set(),
    clicks: /* @__PURE__ */ new Map()
  }, c = {
    pointermove: p,
    pointerup: k,
    pointercancel: w
  };
  function d(g) {
    const f = a.follow.followedPointerId === g.pointerId, m = i.has(g.nodeId), x = !(g.pointerId in a.pointers);
    if (f && x || f && !m) {
      const z = Ye.valueOf(a.pointers).find(($) => i.has($.nodeId));
      if (!z) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      g = z, a.follow.followedPointerId = g.pointerId;
    } else {
      const z = a.pointers.get(a.follow.followedPointerId);
      if (!z) {
        a.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      g = z;
    }
    if (f || m) {
      const z = Ye.valueOf(a.pointers).map(($) => $.nodeId);
      a.follow.nodeBasePositions = Object.fromEntries(
        Array.from(i).filter(($) => !z.includes($)).filter(($) => {
          var C;
          return (C = e[$]) == null ? void 0 : C.draggable;
        }).map(($) => [$, zt(t.nodes, $)])
      ), g.dragBasePosition = se({}, g.latestPosition), g.nodeBasePosition = zt(t.nodes, g.nodeId);
    }
  }
  U(i, (g) => {
    const f = a.pointers.get(a.follow.followedPointerId);
    f && d(f), g.size > 0 && n.selectionMode.value !== "node" ? n.selectionMode.value = "node" : g.size === 0 && n.selectionMode.value === "node" && (n.selectionMode.value = "container");
  }), U(n.selectionMode, (g) => {
    g !== "node" && i.clear();
  });
  function u(g, f) {
    const m = g.dragBasePosition.x - f.pageX, x = g.dragBasePosition.y - f.pageY, z = a.follow.followedPointerId == g.pointerId ? se({
      [g.nodeId]: g.nodeBasePosition
    }, a.follow.nodeBasePositions) : { [g.nodeId]: g.nodeBasePosition }, $ = s.value;
    return Object.fromEntries(
      Object.entries(z).map(([C, T]) => [
        C,
        {
          x: T.x - m / $,
          y: T.y - x / $
        }
      ])
    );
  }
  function h(g, f) {
    var x, z;
    if (f.isTrusted || f.shiftKey && !["container", "node"].includes(n.selectionMode.value))
      return;
    n.selectionMode.value = "node";
    const m = (z = (x = e[g]) == null ? void 0 : x.selectable) != null ? z : !1;
    if (m) {
      const $ = Ye.valueOf(a.pointers).filter((C) => i.has(C.nodeId)).length > 0;
      f.shiftKey || $ ? i.has(g) ? i.delete(g) : typeof m == "number" && i.size >= m || i.add(g) : i.has(g) || (i.clear(), i.add(g));
    }
    r.emit("node:click", { node: g, event: f });
  }
  function l(g, f) {
    f.isTrusted || r.emit("node:dblclick", { node: g, event: f });
  }
  function p(g) {
    var z;
    g.stopPropagation();
    const f = a.pointers.get(g.pointerId);
    if (!f)
      return;
    f.latestPosition = { x: g.pageX, y: g.pageY }, f.moveCounter++;
    const m = lt(g.pointerType);
    if (f.moveCounter <= m || !((z = e[f.nodeId]) != null && z.draggable))
      return;
    if (f.moveCounter === m + 1) {
      const $ = u(f, {
        pointerId: f.pointerId,
        pageX: f.dragBasePosition.x,
        pageY: f.dragBasePosition.y
      });
      r.emit("node:dragstart", $);
    }
    const x = u(f, g);
    r.emit("node:pointermove", x);
  }
  function w(g) {
    g.stopPropagation();
    let f = a.pointers.get(g.pointerId);
    if (f) {
      for (f of a.pointers.values()) {
        const m = f.nodeId, x = lt(g.pointerType);
        if (f.moveCounter > x) {
          const $ = u(f, {
            pointerId: f.pointerId,
            pageX: f.latestPosition.x,
            pageY: f.latestPosition.y
          });
          r.emit("node:dragend", $);
        }
        r.emit("node:pointerup", { node: m, event: g });
      }
      a.pointers.clear(), a.follow = { followedPointerId: -1, nodeBasePositions: {} }, fe(c).forEach(([m, x]) => {
        document.removeEventListener(m, x);
      }), n.viewMode.value = "default";
    }
  }
  function k(g) {
    var $, C, T;
    g.stopPropagation();
    const f = a.pointers.get(g.pointerId);
    if (!f)
      return;
    a.pointers.delete(g.pointerId);
    const m = f.nodeId, x = lt(g.pointerType), z = f.moveCounter > x;
    if (z) {
      if (($ = e[f.nodeId]) != null && $.draggable) {
        const L = u(f, g);
        r.emit("node:dragend", L), r.emit("node:pointerup", { node: m, event: g });
      }
    } else
      r.emit("node:pointerup", { node: m, event: g });
    if (!z) {
      const [L, N] = Yt(
        a.clicks,
        f.pointerId,
        m,
        g
      );
      (C = f.eventTarget) == null || C.dispatchEvent(L), N && ((T = f.eventTarget) == null || T.dispatchEvent(N));
    }
    a.pointers.size === 0 ? (a.follow = { followedPointerId: -1, nodeBasePositions: {} }, fe(c).forEach(([L, N]) => {
      document.removeEventListener(L, N);
    }), Qt(a.clicks), n.viewMode.value = "default") : d(f), o.clear(), a.hoveredNodesPre.forEach(o.add, o);
  }
  function y(g, f) {
    if (f.button == 2 || (f.stopPropagation(), !["default", "node"].includes(n.viewMode.value)))
      return;
    a.pointers.size == 0 && (n.viewMode.value = "node", fe(c).forEach(([x, z]) => {
      document.addEventListener(x, z);
    }));
    const m = {
      pointerId: f.pointerId,
      nodeId: g,
      moveCounter: 0,
      nodeBasePosition: zt(t.nodes, g),
      dragBasePosition: { x: f.pageX, y: f.pageY },
      latestPosition: { x: f.pageX, y: f.pageY },
      eventTarget: f.currentTarget
    };
    a.pointers.set(f.pointerId, m), i.has(g) && (a.follow.followedPointerId < 0 ? (a.follow.followedPointerId = f.pointerId, d(m)) : delete a.follow.nodeBasePositions[m.nodeId]), r.emit("node:pointerdown", { node: g, event: f });
  }
  function v(g, f) {
    a.hoveredNodesPre.add(g), !(a.pointers.size > 0) && (o.add(g), r.emit("node:pointerover", { node: g, event: f }));
  }
  function b(g, f) {
    a.hoveredNodesPre.delete(g), !(a.pointers.size > 0) && (o.delete(g), r.emit("node:pointerout", { node: g, event: f }));
  }
  function E(g, f) {
    f.stopPropagation(), r.emit("node:contextmenu", { node: g, event: f });
  }
  return {
    handleNodePointerDownEvent: y,
    handleNodePointerOverEvent: v,
    handleNodePointerOutEvent: b,
    handleNodeClickEvent: h,
    handleNodeDoubleClickEvent: l,
    handleNodeContextMenu: E
  };
}
function zt(e, t) {
  var o;
  const n = (o = e[t]) != null ? o : { x: 0, y: 0 };
  return se({}, n);
}
function Ri(e, t, n, o, i) {
  const s = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  }, r = {
    pointerup: c,
    pointercancel: d
  };
  U(o, (f) => {
    f.size > 0 && t.selectionMode.value !== "edge" ? t.selectionMode.value = "edge" : f.size === 0 && t.selectionMode.value === "edge" && (t.selectionMode.value = "container");
  }), U(t.selectionMode, (f) => {
    f !== "edge" && o.clear();
  });
  function a(f, m) {
    if (m.button == 2 || (m.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    s.pointers.size == 0 && (t.viewMode.value = "edge", fe(r).forEach(([z, $]) => {
      document.addEventListener(z, $);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const x = {
      pointerId: m.pointerId,
      id: f,
      eventTarget: m.currentTarget
    };
    s.pointers.set(m.pointerId, x), i.emit("edge:pointerdown", be(f, m));
  }
  function c(f) {
    var C, T;
    f.stopPropagation();
    const m = s.pointers.get(f.pointerId);
    if (!m)
      return;
    s.pointers.delete(f.pointerId);
    const x = m.id;
    i.emit("edge:pointerup", be(x, f));
    const [z, $] = Yt(
      s.clicks,
      m.pointerId,
      x instanceof Array ? x.join(",") : x,
      f
    );
    (C = m.eventTarget) == null || C.dispatchEvent(z), $ && ((T = m.eventTarget) == null || T.dispatchEvent($)), s.pointers.size === 0 && (s.pointerPeekCount = 0, fe(r).forEach(([L, N]) => {
      document.removeEventListener(L, N);
    }), Qt(s.clicks), t.viewMode.value = "default");
  }
  function d(f) {
    if (f.stopPropagation(), !!s.pointers.get(f.pointerId)) {
      for (const x of s.pointers.values()) {
        const z = x.id;
        i.emit("edge:pointerup", be(z, f));
      }
      s.pointers.clear(), s.pointerPeekCount = 0, fe(r).forEach(([x, z]) => {
        document.removeEventListener(x, z);
      }), i.emit("view:mode", "default");
    }
  }
  function u(f, m) {
    var $;
    if (m.isTrusted || m.shiftKey && !["container", "edge"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "edge";
    const x = f instanceof Array ? f : [f], z = Ye.valueOf(s.pointers).filter((C) => (C.id instanceof Array ? C.id : [C.id]).every((L) => o.has(L))).length > 0;
    if (f instanceof Array)
      x.find((T) => {
        var L;
        return (L = e[T]) == null ? void 0 : L.selectable;
      }) && (m.shiftKey || z ? x.some((T) => o.has(T)) ? x.forEach((T) => o.delete(T)) : x.forEach((T) => {
        var N;
        const L = (N = e[T]) == null ? void 0 : N.selectable;
        typeof L == "number" && o.size >= L || o.add(T);
      }) : (o.clear(), x.forEach((T) => o.add(T))));
    else {
      const C = ($ = e[f]) == null ? void 0 : $.selectable;
      C && (m.shiftKey || z ? o.has(f) ? o.delete(f) : typeof C == "number" && o.size >= C || o.add(f) : o.has(f) || (o.clear(), o.add(f)));
    }
    i.emit("edge:click", be(f, m));
  }
  function h(f, m) {
    m.isTrusted || i.emit("edge:dblclick", be(f, m));
  }
  function l(f, m) {
    n.add(f), i.emit("edge:pointerover", be(f, m));
  }
  function p(f, m) {
    n.delete(f), i.emit("edge:pointerout", be(f, m));
  }
  function w(f, m) {
    m.stopPropagation(), i.emit("edge:contextmenu", be(f, m));
  }
  function k(f, m) {
    if (m.button == 2 || (m.stopPropagation(), !["default", "edge"].includes(t.viewMode.value)))
      return;
    s.pointers.size == 0 && (t.viewMode.value = "edge", fe(r).forEach(([z, $]) => {
      document.addEventListener(z, $);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const x = {
      pointerId: m.pointerId,
      id: f,
      eventTarget: m.currentTarget
    };
    s.pointers.set(m.pointerId, x), i.emit("edge:pointerdown", be(f, m));
  }
  function y(f, m) {
    f.forEach((x) => n.add(x)), i.emit("edge:pointerover", be(f, m));
  }
  function v(f, m) {
    f.forEach((x) => n.delete(x)), i.emit("edge:pointerout", be(f, m));
  }
  function b(f, m) {
    u(f, m);
  }
  function E(f, m) {
    h(f, m);
  }
  function g(f, m) {
    m.stopPropagation(), i.emit("edge:contextmenu", be(f, m));
  }
  return {
    handleEdgePointerDownEvent: a,
    handleEdgePointerOverEvent: l,
    handleEdgePointerOutEvent: p,
    handleEdgeClickEvent: u,
    handleEdgeDoubleClickEvent: h,
    handleEdgeContextMenu: w,
    handleEdgesPointerDownEvent: k,
    handleEdgesPointerOverEvent: y,
    handleEdgesPointerOutEvent: v,
    handleEdgesClickEvent: b,
    handleEdgesDoubleClickEvent: E,
    handleEdgesContextMenu: g
  };
}
function be(e, t) {
  return e instanceof Array ? {
    edges: e,
    event: t,
    summarized: !0
  } : {
    edge: e,
    edges: [e],
    event: t,
    summarized: !1
  };
}
function Vi(e, t, n, o) {
  const i = {
    moveCounter: 0,
    pointerCounter: 0,
    clickState: void 0
  }, s = {
    pointermove: a,
    pointerup: c,
    pointercancel: c
  };
  function r(p) {
    i.moveCounter = 0, i.pointerCounter === 0 && fe(s).forEach(([w, k]) => {
      document.addEventListener(w, k, { passive: !0 });
    }), i.pointerCounter++;
  }
  function a(p) {
    i.moveCounter++;
  }
  function c(p) {
    if (i.pointerCounter--, i.pointerCounter <= 0) {
      i.pointerCounter = 0, fe(s).forEach(([k, y]) => {
        document.removeEventListener(k, y);
      });
      const w = lt(p.pointerType);
      if (i.moveCounter <= w) {
        if (p.shiftKey && t.selectionMode.value !== "container")
          return;
        t.selectionMode.value = "container";
        const [k, y, v] = Gn(
          i.clickState,
          p,
          "view"
        );
        i.clickState = k, e.value.dispatchEvent(y), v && e.value.dispatchEvent(v);
      }
    }
  }
  function d(p) {
    p.isTrusted || (p.stopPropagation(), o.emit("view:click", { event: p }));
  }
  function u(p) {
    p.isTrusted || (p.stopPropagation(), o.emit("view:dblclick", { event: p }));
  }
  function h(p) {
    o.emit("view:contextmenu", { event: p }), i.pointerCounter > 0 && (i.pointerCounter = 0, fe(s).forEach(([w, k]) => {
      var y;
      (y = e.value) == null || y.removeEventListener(w, k);
    }));
  }
  const l = (p) => {
    p.preventDefault();
  };
  Ue(() => {
    const p = e.value;
    p && (p.addEventListener("pointerdown", r, { passive: !0 }), p.addEventListener("click", d, { passive: !1 }), p.addEventListener("dblclick", u, { passive: !1 }), p.addEventListener("contextmenu", h, { passive: !1 }), n.value && p.addEventListener("wheel", l, { passive: !1 }));
  }), et(() => {
    const p = e.value;
    p && (p.removeEventListener("pointerdown", r), p.removeEventListener("click", d), p.removeEventListener("dblclick", u), p.removeEventListener("contextmenu", h), n.value && p.removeEventListener("wheel", l));
  }), U(n, (p, w) => {
    const k = e.value;
    !k || p === w || (p ? k.addEventListener("wheel", l, { passive: !1 }) : k.removeEventListener("wheel", l));
  });
}
function Wi(e, t, n, o, i, s) {
  const r = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  function a(v, b) {
    var E, g;
    return i.value ? { path: (g = (E = e[v]) == null ? void 0 : E.path) != null ? g : v, event: b } : { path: v, event: b };
  }
  const c = {
    pointerup: u,
    pointercancel: h
  };
  U(o, (v) => {
    v.size > 0 && t.selectionMode.value !== "path" ? t.selectionMode.value = "path" : v.size === 0 && t.selectionMode.value === "path" && (t.selectionMode.value = "container");
  }), U(t.selectionMode, (v) => {
    v !== "path" && o.clear();
  });
  function d(v, b) {
    var g;
    if (!((g = e[v]) != null && g.clickable) || b.button == 2 || (b.stopPropagation(), !["default", "path"].includes(t.viewMode.value)))
      return;
    r.pointers.size == 0 && (t.viewMode.value = "path", fe(c).forEach(([f, m]) => {
      document.addEventListener(f, m);
    }), r.pointerPeekCount = 0), r.pointerPeekCount++;
    const E = {
      pointerId: b.pointerId,
      id: v,
      eventTarget: b.currentTarget
    };
    r.pointers.set(b.pointerId, E), s.emit("path:pointerdown", a(v, b));
  }
  function u(v) {
    var m, x;
    const b = r.pointers.get(v.pointerId);
    if (!b)
      return;
    v.stopPropagation(), r.pointers.delete(v.pointerId);
    const E = b.id;
    s.emit("path:pointerup", a(E, v));
    const [g, f] = Yt(
      r.clicks,
      b.pointerId,
      E,
      v
    );
    (m = b.eventTarget) == null || m.dispatchEvent(g), f && ((x = b.eventTarget) == null || x.dispatchEvent(f)), r.pointers.size === 0 && (r.pointerPeekCount = 0, fe(c).forEach(([z, $]) => {
      document.removeEventListener(z, $);
    }), Qt(r.clicks), t.viewMode.value = "default");
  }
  function h(v) {
    if (r.pointers.get(v.pointerId)) {
      v.stopPropagation();
      for (const E of r.pointers.values()) {
        const g = E.id;
        s.emit("path:pointerup", a(g, v));
      }
      r.pointers.clear(), r.pointerPeekCount = 0, fe(c).forEach(([E, g]) => {
        document.removeEventListener(E, g);
      }), s.emit("view:mode", "default");
    }
  }
  function l(v, b) {
    var E;
    (E = e[v]) != null && E.hoverable && (n.add(v), s.emit("path:pointerover", a(v, b)));
  }
  function p(v, b) {
    var E;
    (E = e[v]) != null && E.hoverable && (n.delete(v), s.emit("path:pointerout", a(v, b)));
  }
  function w(v, b) {
    var g, f, m;
    if (b.isTrusted || !((g = e[v]) != null && g.clickable) || b.shiftKey && !["container", "path"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "path";
    const E = (m = (f = e[v]) == null ? void 0 : f.selectable) != null ? m : !1;
    if (E) {
      const x = Ye.valueOf(r.pointers).filter((z) => o.has(z.id)).length > 0;
      b.shiftKey || x ? o.has(v) ? o.delete(v) : typeof E == "number" && o.size >= E || o.add(v) : o.has(v) || (o.clear(), o.add(v));
    }
    s.emit("path:click", a(v, b));
  }
  function k(v, b) {
    var E;
    b.isTrusted || (E = e[v]) != null && E.clickable && s.emit("path:dblclick", a(v, b));
  }
  function y(v, b) {
    var E;
    (E = e[v]) != null && E.clickable && (b.stopPropagation(), s.emit("path:contextmenu", a(v, b)));
  }
  return {
    handlePathPointerDownEvent: d,
    handlePathPointerOverEvent: l,
    handlePathPointerOutEvent: p,
    handlePathClickEvent: w,
    handlePathDoubleClickEvent: k,
    handlePathContextMenu: y
  };
}
function Hi(e) {
  return ye(this, null, function* () {
    const n = yield (yield fetch(e)).blob();
    return new Promise((o, i) => {
      try {
        const s = new FileReader();
        s.onload = function() {
          o(this.result);
        }, s.readAsDataURL(n);
      } catch (s) {
        i(s);
      }
    });
  });
}
function Dt(e, t, n) {
  var s;
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform((s = t.getCTM()) == null ? void 0 : s.inverse());
  return { x: i.x, y: i.y };
}
function Fi(e, t, n) {
  const o = e.createSVGPoint();
  o.x = n.x, o.y = n.y;
  const i = o.matrixTransform(t.getCTM());
  return { x: i.x, y: i.y };
}
function Kn(e, t, n) {
  var d;
  const o = e.cloneNode(!0), i = t.getBBox(), s = 1 / n, r = {
    x: Math.floor((i.x - 10) * s),
    y: Math.floor((i.y - 10) * s),
    width: Math.ceil((i.width + 20) * s),
    height: Math.ceil((i.height + 20) * s)
  };
  o.setAttribute("width", r.width.toString()), o.setAttribute("height", r.height.toString());
  const a = o.querySelector(".v-ng-viewport");
  a.setAttribute("transform", `translate(${-r.x} ${-r.y}), scale(${s})`), a.removeAttribute("style"), o.setAttribute("viewBox", `0 0 ${r.width} ${r.height}`), o.removeAttribute("style");
  const c = document.createNodeIterator(o, NodeFilter.SHOW_COMMENT);
  for (; c.nextNode(); ) {
    const u = c.referenceNode;
    (d = u.parentNode) == null || d.removeChild(u);
  }
  return o;
}
function Ui(e) {
  return ye(this, null, function* () {
    let t = !1, n = e.getAttribute("href");
    if (n || (t = !0, n = e.getAttribute("xlink:href")), !(!n || n.startsWith("data:")))
      try {
        const o = yield Hi(n);
        e.setAttribute(t ? "xlink:href" : "href", o);
      } catch (o) {
        console.warn("Image download failed.", n);
        return;
      }
  });
}
function Xi(i, s, r) {
  return ye(this, arguments, function* (e, t, n, o = {}) {
    const a = Kn(e, t, n);
    if (o.embedImages) {
      const d = Array.from(a.querySelectorAll("image")).map((u) => Ui(u));
      yield Promise.all(d);
    }
    return a;
  });
}
function qi(e, t, n, o, i, s) {
  const r = O(
    () => !!s.node.selectable && s.view.boxSelectionEnabled
  ), a = O(() => t.viewMode.value === "box-selection"), c = j(), d = j(), u = {
    pointers: /* @__PURE__ */ new Set(),
    // Set of pointers being pressed
    points: /* @__PURE__ */ new Map(),
    // Point indicated by each pointer
    startPoint: null,
    // Point where the drag started
    selectedNodesAtSelectStarted: /* @__PURE__ */ new Set(),
    // Nodes selected at the start of the selection
    selectionType: "append",
    // Selection method for nodes included in the dragged range
    options: {
      // options specified by user at start of selection mode
      stopTrigger: "pointerup",
      selectionType: "append",
      selectionTypeWithShiftKey: "same"
    }
  }, h = Fo(
    () => {
      Gi(
        q(e.value, "container"),
        q(c.value, "viewport"),
        d,
        n.nodes,
        o,
        i,
        u.selectedNodesAtSelectStarted,
        u.selectionType
      );
    },
    50,
    { maxWait: 100 }
  ), l = new Ki(
    e,
    w,
    k,
    y,
    p,
    v
  );
  function p(m) {
    if (u.options.stopTrigger !== "click" || u.pointers.size > 0) return;
    const x = { x: m.offsetX, y: m.offsetY };
    u.startPoint && R.fromObject(u.startPoint).distance(x) > 10 || f();
  }
  function w(m) {
    m.stopPropagation();
    const x = { x: m.offsetX, y: m.offsetY };
    u.pointers.size === 0 && (u.startPoint = x, l.activate(), u.selectedNodesAtSelectStarted.clear(), i.forEach((z) => u.selectedNodesAtSelectStarted.add(z)), u.options.selectionTypeWithShiftKey === "same" ? u.selectionType = u.options.selectionType : u.selectionType = m.shiftKey ? u.options.selectionTypeWithShiftKey : u.options.selectionType), u.pointers.has(m.pointerId) || u.pointers.add(m.pointerId), u.points.set(m.pointerId, x), b();
  }
  function k(m) {
    if (u.pointers.delete(m.pointerId), u.pointers.size === 1) {
      const x = q(e.value).getBoundingClientRect(), z = { x: m.x - x.x, y: m.y - x.y };
      u.startPoint = z;
    } else u.pointers.size === 0 && (l.deactivate(), u.options.stopTrigger === "pointerup" && f(), u.selectedNodesAtSelectStarted.clear());
    b();
  }
  function y(m) {
    const x = q(e.value).getBoundingClientRect(), z = { x: m.x - x.x, y: m.y - x.y };
    u.points.set(m.pointerId, z), b(), h();
  }
  function v(m) {
    m.key === "Escape" && u.options.stopTrigger !== "manual" && (m.stopPropagation(), f());
  }
  function b() {
    let m, x;
    const z = Array.from(u.pointers);
    if (z.length >= 2) {
      const $ = z[0], C = z[z.length - 1];
      m = u.points.get($), x = u.points.get(C);
    } else if (u.startPoint && z.length === 1) {
      const $ = z[0];
      m = u.startPoint, x = u.points.get($);
    } else
      m = void 0, x = void 0;
    m && x ? (d.value = {
      pos: {
        x: Math.min(m.x, x.x),
        y: Math.min(m.y, x.y)
      },
      size: {
        width: Math.abs(x.x - m.x),
        height: Math.abs(x.y - m.y)
      }
    }, d.value.size.width === 0 && (d.value.size.width = 1), d.value.size.height === 0 && (d.value.size.height = 1)) : d.value && (d.value = void 0);
  }
  const E = new Yi(
    e,
    // key down
    (m) => {
      r.value && s.view.selection.detector(m) && (g({
        stop: "manual",
        type: "append",
        withShiftKey: "invert"
      }), E.activate());
    },
    // key up
    (m) => {
      r.value && s.view.selection.detector(m) && (u.pointers.size === 0 ? f() : u.options.stopTrigger = "pointerup", E.deactivate());
    }
  );
  U(r, (m) => {
    m ? E.register() : E.unregister();
  }), Ue(() => {
    var m;
    c.value = (m = e.value) == null ? void 0 : m.querySelector(".v-ng-viewport"), r.value && E.register();
  }), et(() => {
    f(), r.value && E.unregister();
  });
  function g(m = {}) {
    var x, z, $;
    u.options = {
      stopTrigger: (x = m.stop) != null ? x : "pointerup",
      selectionType: (z = m.type) != null ? z : "append",
      selectionTypeWithShiftKey: ($ = m.withShiftKey) != null ? $ : "same"
    }, t.viewMode.value !== "box-selection" && (t.viewMode.value = "box-selection", u.pointers.clear(), l.register());
  }
  function f() {
    t.viewMode.value === "box-selection" && (t.viewMode.value = "default", l.unregister());
  }
  return { isBoxSelectionMode: a, selectionBox: d, startBoxSelection: g, stopBoxSelection: f };
}
function Gi(e, t, n, o, i, s, r, a) {
  if (!n.value) return;
  const c = n.value, d = Dt(e, t, c.pos), u = Dt(e, t, {
    x: c.pos.x + c.size.width,
    y: c.pos.y + c.size.height
  }), h = new Set(
    Object.entries(o).filter(([l, p]) => d.x <= p.x && p.x <= u.x && d.y <= p.y && p.y <= u.y).map(([l, p]) => l)
  );
  if (a === "append")
    s.forEach((l) => {
      h.has(l) || s.delete(l);
    }), h.forEach((l) => {
      var w, k;
      const p = (k = (w = i[l]) == null ? void 0 : w.selectable) != null ? k : !1;
      (p === !0 || typeof p == "number" && s.size < p) && s.add(l);
    });
  else {
    const l = new Set(r);
    l.forEach((p) => {
      h.has(p) && l.delete(p);
    }), h.forEach((p) => {
      var w, k;
      if (!r.has(p)) {
        const y = (k = (w = i[p]) == null ? void 0 : w.selectable) != null ? k : !1;
        (y === !0 || typeof y == "number" && l.size < y) && l.add(p);
      }
    }), s.clear(), l.forEach((p) => s.add(p));
  }
}
class Ki {
  constructor(t, n, o, i, s, r) {
    this._container = t, this._handlePointerDownEvent = n, this._handlePointerUpEvent = o, this._handlePointerMoveEvent = i, this._handleClickEvent = s, this._handleKeyDownEvent = r, this._ignoreEvent = (a) => a.stopPropagation();
  }
  register() {
    const t = { capture: !0, passive: !1 }, n = q(this._container.value, "container");
    n.addEventListener("pointerdown", this._handlePointerDownEvent, t), n.addEventListener("click", this._handleClickEvent, t), n.addEventListener("pointerenter", this._ignoreEvent, t), n.addEventListener("pointerleave", this._ignoreEvent, t), document.addEventListener("keydown", this._handleKeyDownEvent, t);
  }
  activate() {
    const t = { capture: !0, passive: !1 };
    document.addEventListener("pointermove", this._handlePointerMoveEvent, t), document.addEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  deactivate() {
    const t = { capture: !0 };
    document.removeEventListener("pointermove", this._handlePointerMoveEvent, t), document.removeEventListener("pointerup", this._handlePointerUpEvent, t);
  }
  unregister() {
    this.deactivate();
    const t = { capture: !0 };
    if (this._container.value) {
      const n = this._container.value;
      n.removeEventListener("pointerdown", this._handlePointerDownEvent, t), n.removeEventListener("click", this._handleClickEvent, t), n.removeEventListener("pointerenter", this._ignoreEvent, t), n.removeEventListener("pointerleave", this._ignoreEvent, t), document.removeEventListener("keydown", this._handleKeyDownEvent, t);
    }
  }
}
class Yi {
  constructor(t, n, o) {
    this._container = t, this._handleKeyDownEvent = n, this._handleKeyUpEvent = o, this._preventDefault = (i) => {
      i.stopPropagation(), i.preventDefault();
    };
  }
  register() {
    document.addEventListener("keydown", this._handleKeyDownEvent, { capture: !0, passive: !0 });
  }
  activate() {
    document.addEventListener("keyup", this._handleKeyUpEvent, { capture: !0, passive: !0 }), q(this._container.value, "container").addEventListener("contextmenu", this._preventDefault, { passive: !1 });
  }
  deactivate() {
    document.removeEventListener("keyup", this._handleKeyUpEvent, { capture: !0 }), this._container.value && this._container.value.removeEventListener("contextmenu", this._preventDefault);
  }
  unregister() {
    this.deactivate(), document.removeEventListener("keydown", this._handleKeyDownEvent, { capture: !0 });
  }
}
const Yn = Symbol("mouseEventHandlers");
function Qi(e, t, n, o, i, s, r, a, c, d, u, h, l, p, w, k) {
  const y = {
    selectionMode: j("container"),
    viewMode: j("default")
  };
  r.size > 0 ? y.selectionMode.value = "node" : a.size > 0 ? y.selectionMode.value = "edge" : c.size > 0 && (y.selectionMode.value = "path"), U(y.viewMode, (b) => {
    k.emit("view:mode", b);
  }), Vi(e, y, p, k);
  const v = se(se(se(se({
    selectedNodes: r,
    hoveredNodes: d,
    selectedEdges: a,
    hoveredEdges: u,
    selectedPaths: c,
    hoveredPaths: h
  }, Bi(
    o,
    t,
    y,
    d,
    r,
    n,
    k
  )), Ri(i, y, u, a, k)), Wi(
    s,
    y,
    h,
    c,
    l,
    k
  )), qi(
    e,
    y,
    t,
    o,
    r,
    w
  ));
  return $e(Yn, v), v;
}
function ot() {
  return q(Le(Yn), "mouseEventHandlers");
}
function Ji(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t, n) {
    var o = e.get(t);
    o ? o.push(n) : e.set(t, [n]);
  }, off: function(t, n) {
    var o = e.get(t);
    o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : e.set(t, []));
  }, emit: function(t, n) {
    var o = e.get(t);
    o && o.slice().map(function(i) {
      i(n);
    }), (o = e.get("*")) && o.slice().map(function(i) {
      i(t, n);
    });
  } };
}
const Qn = Symbol("emitter");
function es() {
  const e = Ji();
  return $e(Qn, e), e;
}
function ts() {
  return q(Le(Qn), "event emitter");
}
var dt = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function ns(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var yt = {
  /**
   * Get global this object
   *
   * @return {Object}        global this object
   */
  getGlobalThis: function() {
    if (typeof globalThis != "undefined") return globalThis;
    if (typeof self != "undefined") return self;
    if (typeof window != "undefined") return window;
    if (typeof dt != "undefined") return dt;
    if (typeof this != "undefined") return this;
    throw new Error("Unable to locate global `this`");
  },
  /**
   * Extends an object
   *
   * @param  {Object} target object to extend
   * @param  {Object} source object to take properties from
   * @return {Object}        extended object
   */
  extend: function(e, t) {
    e = e || {};
    for (var n in t)
      this.isObject(t[n]) ? e[n] = this.extend(e[n], t[n]) : e[n] = t[n];
    return e;
  },
  /**
   * Checks if an object is a DOM element
   *
   * @param  {Object}  o HTML element or String
   * @return {Boolean}   returns true if object is a DOM element
   */
  isElement: function(e) {
    return e instanceof HTMLElement || e instanceof SVGElement || e instanceof SVGSVGElement || //DOM2
    e && typeof e == "object" && e !== null && e.nodeType === 1 && typeof e.nodeName == "string";
  },
  /**
   * Checks if an object is an Object
   *
   * @param  {Object}  o Object
   * @return {Boolean}   returns true if object is an Object
   */
  isObject: function(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
  },
  /**
   * Checks if variable is Number
   *
   * @param  {Integer|Float}  n
   * @return {Boolean}   returns true if variable is Number
   */
  isNumber: function(e) {
    return !isNaN(parseFloat(e)) && isFinite(e);
  },
  /**
   * Search for an SVG element
   *
   * @param  {Object|String} elementOrSelector DOM Element or selector String
   * @return {Object|Null}                   SVG or null
   */
  getSvg: function(e) {
    var t, n;
    if (this.isElement(e))
      t = e;
    else if (typeof e == "string" || e instanceof String) {
      if (t = document.querySelector(e), !t)
        throw new Error(
          "Provided selector did not find any elements. Selector: " + e
        );
    } else
      throw new Error("Provided selector is not an HTML object nor String");
    if (t.tagName.toLowerCase() === "svg")
      n = t;
    else if (t.tagName.toLowerCase() === "object")
      n = t.contentDocument.documentElement;
    else if (t.tagName.toLowerCase() === "embed")
      n = t.getSVGDocument().documentElement;
    else
      throw t.tagName.toLowerCase() === "img" ? new Error(
        'Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.'
      ) : new Error("Cannot get SVG.");
    return n;
  },
  /**
   * Attach a given context to a function
   * @param  {Function} fn      Function
   * @param  {Object}   context Context
   * @return {Function}           Function with certain context
   */
  proxy: function(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  },
  /**
   * Returns object type
   * Uses toString that returns [object SVGPoint]
   * And than parses object type from string
   *
   * @param  {Object} o Any object
   * @return {String}   Object type
   */
  getType: function(e) {
    return Object.prototype.toString.apply(e).replace(/^\[object\s/, "").replace(/\]$/, "");
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   */
  mouseAndTouchNormalize: function(e, t) {
    if (e.clientX === void 0 || e.clientX === null)
      if (e.clientX = 0, e.clientY = 0, e.touches !== void 0 && e.touches.length) {
        if (e.touches[0].clientX !== void 0)
          e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY;
        else if (e.touches[0].pageX !== void 0) {
          var n = t.getBoundingClientRect();
          e.clientX = e.touches[0].pageX - n.left, e.clientY = e.touches[0].pageY - n.top;
        }
      } else e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY);
  },
  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   */
  touchNormalize: function(e, t, n) {
    if (e.touches !== void 0 && e.touches.length) {
      if (e.touches[n].clientX !== void 0)
        e.clientX = e.touches[n].clientX, e.clientY = e.touches[n].clientY;
      else if (e.touches[n].pageX !== void 0) {
        var o = t.getBoundingClientRect();
        e.clientX = e.touches[n].pageX - o.left, e.clientY = e.touches[n].pageY - o.top;
      }
    } else
      (e.clientX === void 0 || e.clientX === null) && (e.clientX = 0, e.clientY = 0, e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY));
  },
  /**
   * Check if an event is a double click/tap
   * TODO: For touch gestures use a library (hammer.js) that takes in account other events
   * (touchmove and touchend). It should take in account tap duration and traveled distance
   *
   * @param  {Event}  evt
   * @param  {Event}  prevEvt Previous Event
   * @return {Boolean}
   */
  isDblClick: function(e, t) {
    if (e.detail === 2)
      return !0;
    if (t != null) {
      var n = e.timeStamp - t.timeStamp, o = Math.sqrt(
        Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)
      );
      return n < 250 && o < 10;
    }
    return !1;
  },
  /**
   * Returns current timestamp as an integer
   *
   * @return {Number}
   */
  now: Date.now || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  },
  // From underscore.
  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  throttle: function(e, t, n) {
    var o = this, i, s, r, a = null, c = 0;
    n || (n = {});
    var d = function() {
      c = n.leading === !1 ? 0 : o.now(), a = null, r = e.apply(i, s), a || (i = s = null);
    };
    return function() {
      var u = o.now();
      !c && n.leading === !1 && (c = u);
      var h = t - (u - c);
      return i = this, s = arguments, h <= 0 || h > t ? (clearTimeout(a), a = null, c = u, r = e.apply(i, s), a || (i = s = null)) : !a && n.trailing !== !1 && (a = setTimeout(d, h)), r;
    };
  },
  /**
   * Create a requestAnimationFrame simulation
   *
   * @param  {Number|String} refreshRate
   * @return {Function}
   */
  createRequestAnimationFrame: function(e) {
    var t = null;
    return e !== "auto" && e < 60 && e > 1 && (t = Math.floor(1e3 / e)), t === null ? window.requestAnimationFrame || Pn(33) : Pn(t);
  },
  /**
   * Calculate distance of points
   *
   * @param  {SVGPoint} point1
   * @param  {SVGPoint} point2
   * @return {Number}
   */
  calculateDistance: function(e, t) {
    var n = e.x - t.x, o = e.y - t.y;
    return Math.sqrt(n * n + o * o);
  }
};
function Pn(e) {
  return function(t) {
    window.setTimeout(t, e);
  };
}
var os = yt, is = function() {
  var e = "", t, n, o, i = [], s = { passive: !0 }, r = { passive: !1 };
  os.getGlobalThis().addEventListener ? (t = "addEventListener", n = "removeEventListener") : (t = "attachEvent", n = "detachEvent", e = "on");
  function a() {
    return o || (o = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll"), o;
  }
  function c(k, y) {
    var v = function(b) {
      !b && (b = window.event);
      var E = {
        // keep a ref to the original event object
        originalEvent: b,
        target: b.target || b.srcElement,
        type: "wheel",
        deltaMode: b.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          b.preventDefault ? b.preventDefault() : b.returnValue = !1;
        }
      };
      return a() == "mousewheel" ? (E.deltaY = -0.025 * b.wheelDelta, b.wheelDeltaX && (E.deltaX = -0.025 * b.wheelDeltaX)) : E.deltaY = b.detail, y(E);
    };
    return i.push({
      element: k,
      fn: v
    }), v;
  }
  function d(k) {
    for (var y = 0; y < i.length; y++)
      if (i[y].element === k)
        return i[y].fn;
    return function() {
    };
  }
  function u(k) {
    for (var y = 0; y < i.length; y++)
      if (i[y].element === k)
        return i.splice(y, 1);
  }
  function h(k, y, v, b) {
    var E;
    a() === "wheel" ? E = v : E = c(k, v), k[t](
      e + y,
      E,
      b ? s : r
    );
  }
  function l(k, y, v, b) {
    var E;
    a() === "wheel" ? E = v : E = d(k), k[n](
      e + y,
      E,
      b ? s : r
    ), u(k);
  }
  function p(k, y, v) {
    h(k, a(), y, v), a() == "DOMMouseScroll" && h(
      k,
      "MozMousePixelScroll",
      y,
      v
    );
  }
  function w(k, y, v) {
    l(k, a(), y, v), a() == "DOMMouseScroll" && l(
      k,
      "MozMousePixelScroll",
      y,
      v
    );
  }
  return {
    on: p,
    off: w
  };
}(), rt = yt, Jn = "unknown";
/*@cc_on!@*/
typeof document != "undefined" && document.documentMode && (Jn = "ie");
var Jt = {
  svgNS: "http://www.w3.org/2000/svg",
  xmlNS: "http://www.w3.org/XML/1998/namespace",
  xmlnsNS: "http://www.w3.org/2000/xmlns/",
  xlinkNS: "http://www.w3.org/1999/xlink",
  evNS: "http://www.w3.org/2001/xml-events",
  /**
   * Get svg dimensions: width and height
   *
   * @param  {SVGSVGElement} svg
   * @return {Object}     {width: 0, height: 0}
   */
  getBoundingClientRectNormalized: function(e) {
    if (e.clientWidth && e.clientHeight)
      return { width: e.clientWidth, height: e.clientHeight };
    if (e.getBoundingClientRect())
      return e.getBoundingClientRect();
    throw new Error("Cannot get BoundingClientRect for SVG.");
  },
  /**
   * Gets g element with class of "viewport" or creates it if it doesn't exist
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGElement}     g (group) element
   */
  getOrCreateViewport: function(e, t) {
    var n = null;
    if (rt.isElement(t) ? n = t : n = e.querySelector(t), !n) {
      var o = Array.prototype.slice.call(e.childNodes || e.children).filter(function(c) {
        return c.nodeName !== "defs" && c.nodeName !== "#text";
      });
      o.length === 1 && o[0].nodeName === "g" && o[0].getAttribute("transform") === null && (n = o[0]);
    }
    if (!n) {
      var i = "viewport-" + (/* @__PURE__ */ new Date()).toISOString().replace(/\D/g, "");
      n = document.createElementNS(this.svgNS, "g"), n.setAttribute("id", i);
      var s = e.childNodes || e.children;
      if (s && s.length > 0)
        for (var r = s.length; r > 0; r--)
          s[s.length - r].nodeName !== "defs" && n.appendChild(s[s.length - r]);
      e.appendChild(n);
    }
    var a = [];
    return n.getAttribute("class") && (a = n.getAttribute("class").split(" ")), ~a.indexOf("svg-pan-zoom_viewport") || (a.push("svg-pan-zoom_viewport"), n.setAttribute("class", a.join(" "))), n;
  },
  /**
   * Set SVG attributes
   *
   * @param  {SVGSVGElement} svg
   */
  setupSvgAttributes: function(e) {
    if (e.setAttribute("xmlns", this.svgNS), e.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS), e.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS), e.parentNode !== null) {
      var t = e.getAttribute("style") || "";
      t.toLowerCase().indexOf("overflow") === -1 && e.setAttribute("style", "overflow: hidden; " + t);
    }
  },
  /**
   * How long Internet Explorer takes to finish updating its display (ms).
   */
  internetExplorerRedisplayInterval: 300,
  /**
   * Forces the browser to redisplay all SVG elements that rely on an
   * element defined in a 'defs' section. It works globally, for every
   * available defs element on the page.
   * The throttling is intentionally global.
   *
   * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)
   * visible after pan/zoom when there are multiple SVGs on the page.
   * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/
   * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62
   */
  refreshDefsGlobal: rt.throttle(
    function() {
      for (var e = document.querySelectorAll("defs"), t = e.length, n = 0; n < t; n++) {
        var o = e[n];
        o.parentNode.insertBefore(o, o);
      }
    },
    dt ? dt.internetExplorerRedisplayInterval : null
  ),
  /**
   * Sets the current transform matrix of an element
   *
   * @param {SVGElement} element
   * @param {SVGMatrix} matrix  CTM
   * @param {SVGElement} defs
   */
  setCTM: function(e, t, n) {
    var o = this, i = "matrix(" + t.a + "," + t.b + "," + t.c + "," + t.d + "," + t.e + "," + t.f + ")";
    e.setAttributeNS(null, "transform", i), "transform" in e.style ? e.style.transform = i : "-ms-transform" in e.style ? e.style["-ms-transform"] = i : "-webkit-transform" in e.style && (e.style["-webkit-transform"] = i), Jn === "ie" && n && (n.parentNode.insertBefore(n, n), window.setTimeout(function() {
      o.refreshDefsGlobal();
    }, o.internetExplorerRedisplayInterval));
  },
  /**
   * Instantiate an SVGPoint object with given event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}     point
   */
  getEventPoint: function(e, t) {
    var n = t.createSVGPoint();
    return rt.mouseAndTouchNormalize(e, t), n.x = e.clientX, n.y = e.clientY, n;
  },
  /**
   * Instantiate an SVGPoint object with given touch event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @param  {Number} touch
   * @return {SVGPoint}     point
   */
  getTouchPoint: function(e, t, n) {
    var o = t.createSVGPoint();
    return rt.touchNormalize(e, t, n), o.x = e.clientX, o.y = e.clientY, o;
  },
  /**
   * Get SVG center point
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}
   */
  getSvgCenterPoint: function(e, t, n) {
    return this.createSVGPoint(e, t / 2, n / 2);
  },
  /**
   * Create a SVGPoint with given x and y
   *
   * @param  {SVGSVGElement} svg
   * @param  {Number} x
   * @param  {Number} y
   * @return {SVGPoint}
   */
  createSVGPoint: function(e, t, n) {
    var o = e.createSVGPoint();
    return o.x = t, o.y = n, o;
  }
}, pe = Jt, ss = {
  enable: function(e) {
    var t = e.svg.querySelector("defs");
    t || (t = document.createElementNS(pe.svgNS, "defs"), e.svg.appendChild(t));
    var n = t.querySelector("style#svg-pan-zoom-controls-styles");
    if (!n) {
      var o = document.createElementNS(pe.svgNS, "style");
      o.setAttribute("id", "svg-pan-zoom-controls-styles"), o.setAttribute("type", "text/css"), o.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }", t.appendChild(o);
    }
    var i = document.createElementNS(pe.svgNS, "g");
    i.setAttribute("id", "svg-pan-zoom-controls"), i.setAttribute(
      "transform",
      "translate(" + (e.width - 70) + " " + (e.height - 76) + ") scale(0.75)"
    ), i.setAttribute("class", "svg-pan-zoom-control"), i.appendChild(this._createZoomIn(e)), i.appendChild(this._createZoomReset(e)), i.appendChild(this._createZoomOut(e)), e.svg.appendChild(i), e.controlIcons = i;
  },
  _createZoomIn: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-in"), t.setAttribute("transform", "translate(30.5 5) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomIn();
      },
      !1
    );
    var n = document.createElementNS(pe.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(pe.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  _createZoomReset: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-reset-pan-zoom"), t.setAttribute("transform", "translate(5 35) scale(0.4)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().reset();
      },
      !1
    );
    var n = document.createElementNS(
      pe.svgNS,
      "rect"
    );
    n.setAttribute("x", "2"), n.setAttribute("y", "2"), n.setAttribute("width", "182"), n.setAttribute("height", "58"), n.setAttribute(
      "class",
      "svg-pan-zoom-control-background"
    ), t.appendChild(n);
    var o = document.createElementNS(
      pe.svgNS,
      "path"
    );
    o.setAttribute(
      "d",
      "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z"
    ), o.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(o);
    var i = document.createElementNS(
      pe.svgNS,
      "path"
    );
    return i.setAttribute(
      "d",
      "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z"
    ), i.setAttribute(
      "class",
      "svg-pan-zoom-control-element"
    ), t.appendChild(i), t;
  },
  _createZoomOut: function(e) {
    var t = document.createElementNS(pe.svgNS, "g");
    t.setAttribute("id", "svg-pan-zoom-zoom-out"), t.setAttribute("transform", "translate(30.5 70) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
      "click",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    ), t.addEventListener(
      "touchstart",
      function() {
        e.getPublicInstance().zoomOut();
      },
      !1
    );
    var n = document.createElementNS(pe.svgNS, "rect");
    n.setAttribute("x", "0"), n.setAttribute("y", "0"), n.setAttribute("width", "1500"), n.setAttribute("height", "1400"), n.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(n);
    var o = document.createElementNS(pe.svgNS, "path");
    return o.setAttribute(
      "d",
      "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z"
    ), o.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(o), t;
  },
  disable: function(e) {
    e.controlIcons && (e.controlIcons.parentNode.removeChild(e.controlIcons), e.controlIcons = null);
  }
}, rs = Jt, Ie = yt, ie = function(e, t) {
  this.init(e, t);
};
ie.prototype.init = function(e, t) {
  this.viewport = e, this.options = t, this.originalState = { zoom: 1, x: 0, y: 0 }, this.activeState = { zoom: 1, x: 0, y: 0 }, this.updateCTMCached = Ie.proxy(this.updateCTM, this), this.requestAnimationFrame = Ie.createRequestAnimationFrame(
    this.options.refreshRate
  ), this.viewBox = { x: 0, y: 0, width: 0, height: 0 }, this.cacheViewBox();
  var n = this.processCTM();
  this.setCTM(n), this.updateCTM();
};
ie.prototype.cacheViewBox = function() {
  var e = this.options.svg.getAttribute("viewBox");
  if (e) {
    var t = e.split(/[\s\,]/).filter(function(o) {
      return o;
    }).map(parseFloat);
    this.viewBox.x = t[0], this.viewBox.y = t[1], this.viewBox.width = t[2], this.viewBox.height = t[3];
    var n = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    );
    this.activeState.zoom = isFinite(n) ? n : 1, this.activeState.x = (this.options.width - this.viewBox.width * n) / 2, this.activeState.y = (this.options.height - this.viewBox.height * n) / 2, this.updateCTMOnNextFrame(), this.options.svg.removeAttribute("viewBox");
  } else
    this.simpleViewBoxCache();
};
ie.prototype.simpleViewBoxCache = function() {
  var e = this.viewport.getBBox();
  this.viewBox.x = e.x, this.viewBox.y = e.y, this.viewBox.width = e.width, this.viewBox.height = e.height;
};
ie.prototype.getViewBox = function() {
  return Ie.extend({}, this.viewBox);
};
ie.prototype.processCTM = function() {
  var e = this.getCTM();
  if (this.options.fit || this.options.contain) {
    var t;
    this.options.fit ? t = Math.min(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ) : t = Math.max(
      this.options.width / this.viewBox.width,
      this.options.height / this.viewBox.height
    ), t = isFinite(t) ? t : 1, e.a = t, e.d = t, e.e = -this.viewBox.x * t, e.f = -this.viewBox.y * t;
  }
  if (this.options.center) {
    var n = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * e.a) * 0.5, o = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * e.a) * 0.5;
    e.e = n, e.f = o;
  }
  return this.originalState.zoom = e.a, this.originalState.x = e.e, this.originalState.y = e.f, e;
};
ie.prototype.getOriginalState = function() {
  return Ie.extend({}, this.originalState);
};
ie.prototype.getState = function() {
  return Ie.extend({}, this.activeState);
};
ie.prototype.getZoom = function() {
  return this.activeState.zoom;
};
ie.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom;
};
ie.prototype.computeRelativeZoom = function(e) {
  return e / this.originalState.zoom;
};
ie.prototype.getPan = function() {
  return { x: this.activeState.x, y: this.activeState.y };
};
ie.prototype.getCTM = function() {
  var e = this.options.svg.createSVGMatrix();
  return e.a = this.activeState.zoom, e.b = 0, e.c = 0, e.d = this.activeState.zoom, e.e = this.activeState.x, e.f = this.activeState.y, e;
};
ie.prototype.setCTM = function(e) {
  var t = this.isZoomDifferent(e), n = this.isPanDifferent(e);
  if (t || n) {
    if (t && (this.options.beforeZoom(
      this.getRelativeZoom(),
      this.computeRelativeZoom(e.a)
    ) === !1 ? (e.a = e.d = this.activeState.zoom, t = !1) : (this.updateCache(e), this.options.onZoom(this.getRelativeZoom()))), n) {
      var o = this.options.beforePan(this.getPan(), {
        x: e.e,
        y: e.f
      }), i = !1, s = !1;
      o === !1 ? (e.e = this.getPan().x, e.f = this.getPan().y, i = s = !0) : Ie.isObject(o) && (o.x === !1 ? (e.e = this.getPan().x, i = !0) : Ie.isNumber(o.x) && (e.e = o.x), o.y === !1 ? (e.f = this.getPan().y, s = !0) : Ie.isNumber(o.y) && (e.f = o.y)), i && s || !this.isPanDifferent(e) ? n = !1 : (this.updateCache(e), this.options.onPan(this.getPan()));
    }
    (t || n) && this.updateCTMOnNextFrame();
  }
};
ie.prototype.isZoomDifferent = function(e) {
  return this.activeState.zoom !== e.a;
};
ie.prototype.isPanDifferent = function(e) {
  return this.activeState.x !== e.e || this.activeState.y !== e.f;
};
ie.prototype.updateCache = function(e) {
  this.activeState.zoom = e.a, this.activeState.x = e.e, this.activeState.y = e.f;
};
ie.prototype.pendingUpdate = !1;
ie.prototype.updateCTMOnNextFrame = function() {
  this.pendingUpdate || (this.pendingUpdate = !0, this.requestAnimationFrame.call(window, this.updateCTMCached));
};
ie.prototype.updateCTM = function() {
  var e = this.getCTM();
  rs.setCTM(this.viewport, e, this.defs), this.pendingUpdate = !1, this.options.onUpdatedCTM && this.options.onUpdatedCTM(e);
};
var as = function(e, t) {
  return new ie(e, t);
}, eo = is, Nt = ss, de = yt, re = Jt, ls = as, X = function(e, t) {
  this.init(e, t);
}, cs = {
  viewportSelector: ".svg-pan-zoom_viewport",
  // Viewport selector. Can be querySelector string or SVGElement
  panEnabled: !0,
  // enable or disable panning (default enabled)
  controlIconsEnabled: !1,
  // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
  zoomEnabled: !0,
  // enable or disable zooming (default enabled)
  dblClickZoomEnabled: !0,
  // enable or disable zooming by double clicking (default enabled)
  mouseWheelZoomEnabled: !0,
  // enable or disable zooming by mouse wheel (default enabled)
  preventMouseEventsDefault: !0,
  // enable or disable preventDefault for mouse events
  zoomScaleSensitivity: 0.1,
  // Zoom sensitivity
  minZoom: 0.5,
  // Minimum Zoom level
  maxZoom: 10,
  // Maximum Zoom level
  fit: !0,
  // enable or disable viewport fit in SVG (default true)
  contain: !1,
  // enable or disable viewport contain the svg (default false)
  center: !0,
  // enable or disable viewport centering in SVG (default true)
  refreshRate: "auto",
  // Maximum number of frames per second (altering SVG's viewport)
  beforeZoom: null,
  onZoom: null,
  beforePan: null,
  onPan: null,
  customEventsHandler: null,
  eventsListenerElement: null,
  onUpdatedCTM: null
}, to = { passive: !0 }, no = { passive: !1 };
X.prototype.init = function(e, t) {
  var n = this;
  this.svg = e, this.defs = e.querySelector("defs"), re.setupSvgAttributes(this.svg), this.options = de.extend(de.extend({}, cs), t), this.state = "none";
  var o = re.getBoundingClientRectNormalized(e);
  this.width = o.width, this.height = o.height, this.viewport = ls(
    re.getOrCreateViewport(this.svg, this.options.viewportSelector),
    {
      svg: this.svg,
      width: this.width,
      height: this.height,
      fit: this.options.fit,
      contain: this.options.contain,
      center: this.options.center,
      refreshRate: this.options.refreshRate,
      // Put callbacks into functions as they can change through time
      beforeZoom: function(s, r) {
        if (n.viewport && n.options.beforeZoom)
          return n.options.beforeZoom(s, r);
      },
      onZoom: function(s) {
        if (n.viewport && n.options.onZoom)
          return n.options.onZoom(s);
      },
      beforePan: function(s, r) {
        if (n.viewport && n.options.beforePan)
          return n.options.beforePan(s, r);
      },
      onPan: function(s) {
        if (n.viewport && n.options.onPan)
          return n.options.onPan(s);
      },
      onUpdatedCTM: function(s) {
        if (n.viewport && n.options.onUpdatedCTM)
          return n.options.onUpdatedCTM(s);
      }
    }
  );
  var i = this.getPublicInstance();
  i.setBeforeZoom(this.options.beforeZoom), i.setOnZoom(this.options.onZoom), i.setBeforePan(this.options.beforePan), i.setOnPan(this.options.onPan), i.setOnUpdatedCTM(this.options.onUpdatedCTM), this.options.controlIconsEnabled && Nt.enable(this), this.lastMouseWheelEventTime = Date.now(), this.setupHandlers();
};
X.prototype.setupHandlers = function() {
  var e = this, t = null;
  if (this.eventListeners = {
    // Mouse down group
    pointerdown: function(s) {
      if (s.pointerType !== "touch") {
        var r = e.handleMouseDown(s, t);
        return t = s, r;
      }
    },
    touchstart: function(s) {
      var r = e.handleTouchStart(s, t);
      return t = s, r;
    },
    // Mouse up group
    pointerup: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    touchend: function(s) {
      return e.handleTouchEnd(s);
    },
    // Mouse move group
    pointermove: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseMove(s);
    },
    touchmove: function(s) {
      return e.handleTouchMove(s);
    },
    // Mouse leave group
    pointerleave: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    pointercancel: function(s) {
      if (s.pointerType !== "touch")
        return e.handleMouseUp(s);
    },
    touchleave: function(s) {
      return e.handleTouchEnd(s);
    },
    touchcancel: function(s) {
      return e.handleTouchEnd(s);
    }
  }, this.options.customEventsHandler != null) {
    this.options.customEventsHandler.init({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    var n = this.options.customEventsHandler.haltEventListeners;
    if (n && n.length)
      for (var o = n.length - 1; o >= 0; o--)
        this.eventListeners.hasOwnProperty(n[o]) && delete this.eventListeners[n[o]];
  }
  for (var i in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).addEventListener(
      i,
      this.eventListeners[i],
      this.options.preventMouseEventsDefault ? no : to
    );
  this.options.mouseWheelZoomEnabled && (this.options.mouseWheelZoomEnabled = !1, this.enableMouseWheelZoom());
};
X.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var e = this;
    this.wheelListener = function(n) {
      return e.handleMouseWheel(n);
    };
    var t = !this.options.preventMouseEventsDefault;
    eo.on(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      t
    ), this.options.mouseWheelZoomEnabled = !0;
  }
};
X.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    var e = !this.options.preventMouseEventsDefault;
    eo.off(
      this.options.eventsListenerElement || this.svg,
      this.wheelListener,
      e
    ), this.options.mouseWheelZoomEnabled = !1;
  }
};
X.prototype.handleMouseWheel = function(e) {
  if (!(!this.options.zoomEnabled || this.state !== "none")) {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1);
    var t = e.deltaY || 1, n = Date.now() - this.lastMouseWheelEventTime, o = 3 + Math.max(0, 30 - n);
    this.lastMouseWheelEventTime = Date.now(), "deltaMode" in e && e.deltaMode === 0 && e.wheelDelta && (t = e.deltaY === 0 ? 0 : Math.abs(e.wheelDelta) / e.deltaY), t = -0.3 < t && t < 0.3 ? t : (t > 0 ? 1 : -1) * Math.log(Math.abs(t) + 10) / o;
    var i = this.svg.getScreenCTM().inverse(), s = re.getEventPoint(e, this.svg).matrixTransform(
      i
    ), r = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * t);
    this.zoomAtPoint(r, s);
  }
};
X.prototype.zoomAtPoint = function(e, t, n) {
  var o = this.viewport.getOriginalState();
  n ? (e = Math.max(
    this.options.minZoom * o.zoom,
    Math.min(this.options.maxZoom * o.zoom, e)
  ), e = e / this.getZoom()) : this.getZoom() * e < this.options.minZoom * o.zoom ? e = this.options.minZoom * o.zoom / this.getZoom() : this.getZoom() * e > this.options.maxZoom * o.zoom && (e = this.options.maxZoom * o.zoom / this.getZoom());
  var i = this.viewport.getCTM(), s = t.matrixTransform(i.inverse()), r = this.svg.createSVGMatrix().translate(s.x, s.y).scale(e).translate(-s.x, -s.y), a = i.multiply(r);
  a.a !== i.a && this.viewport.setCTM(a);
};
X.prototype.zoom = function(e, t) {
  this.zoomAtPoint(
    e,
    re.getSvgCenterPoint(this.svg, this.width, this.height),
    t
  );
};
X.prototype.publicZoom = function(e, t) {
  t && (e = this.computeFromRelativeZoom(e)), this.zoom(e, t);
};
X.prototype.publicZoomAtPoint = function(e, t, n) {
  if (n && (e = this.computeFromRelativeZoom(e)), de.getType(t) !== "SVGPoint")
    if ("x" in t && "y" in t)
      t = re.createSVGPoint(this.svg, t.x, t.y);
    else
      throw new Error("Given point is invalid");
  this.zoomAtPoint(e, t, n);
};
X.prototype.getZoom = function() {
  return this.viewport.getZoom();
};
X.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom();
};
X.prototype.computeFromRelativeZoom = function(e) {
  return e * this.viewport.getOriginalState().zoom;
};
X.prototype.resetZoom = function() {
  var e = this.viewport.getOriginalState();
  this.zoom(e.zoom, !0);
};
X.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
};
X.prototype.reset = function() {
  this.resetZoom(), this.resetPan();
};
X.prototype.handleDblClick = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.options.controlIconsEnabled) {
    var t = e.target.getAttribute("class") || "";
    if (t.indexOf("svg-pan-zoom-control") > -1)
      return !1;
  }
  var n;
  e.shiftKey ? n = 1 / ((1 + this.options.zoomScaleSensitivity) * 2) : n = (1 + this.options.zoomScaleSensitivity) * 2;
  var o = re.getEventPoint(e, this.svg).matrixTransform(
    this.svg.getScreenCTM().inverse()
  );
  this.zoomAtPoint(n, o);
};
X.prototype.handleMouseDown = function(e, t) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), de.mouseAndTouchNormalize(e, this.svg), this.options.dblClickZoomEnabled && de.isDblClick(e, t) ? this.handleDblClick(e) : (this.state = "pan", this.firstEventCTM = this.viewport.getCTM(), this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
    this.firstEventCTM.inverse()
  ));
};
X.prototype.handleMouseMove = function(e) {
  if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && this.options.panEnabled) {
    var t = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    ), n = this.firstEventCTM.translate(
      t.x - this.stateOrigin.x,
      t.y - this.stateOrigin.y
    );
    this.viewport.setCTM(n);
  }
};
X.prototype.handleMouseUp = function(e) {
  this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.state === "pan" && (this.state = "none");
};
X.prototype.handleTouchStart = function(e, t) {
  if (e.touches.length == 1)
    this.handleMouseDown(e, t);
  else {
    this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM();
    var n = re.getTouchPoint(e, this.svg, 0), o = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = de.calculateDistance(n, o), n.x = (n.x + o.x) / 2, n.y = (n.y + o.y) / 2, this.stateOrigin = n.matrixTransform(this.firstEventCTM.inverse()), this.firstZoomLevel = this.getZoom();
  }
};
X.prototype.handleTouchMove = function(e) {
  if (e.touches.length == 1)
    this.handleMouseMove(e);
  else {
    if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), !this.options.panEnabled && !this.options.zoomEnabled)
      return;
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1), o = this.svg.createSVGPoint();
    if (o.x = (t.x + n.x) / 2, o.y = (t.y + n.y) / 2, this.state === "pan" && this.options.panEnabled) {
      var i = o.matrixTransform(this.firstEventCTM.inverse()), s = this.firstEventCTM.translate(
        i.x - this.stateOrigin.x,
        i.y - this.stateOrigin.y
      );
      this.viewport.setCTM(s);
    }
    if (this.options.zoomEnabled) {
      var r = de.calculateDistance(t, n), a = r / this.firstDistance, c = this.svg.getScreenCTM().inverse(), d = o.matrixTransform(c);
      this.zoomAtPoint(this.firstZoomLevel * a, d, !0);
    }
  }
};
X.prototype.handleTouchEnd = function(e) {
  if (e.touches.length == 0)
    this.handleMouseUp(e);
  else if (this.options.preventMouseEventsDefault && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), this.firstEventCTM = this.viewport.getCTM(), e.touches.length == 1)
    this.stateOrigin = re.getEventPoint(e, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    );
  else {
    var t = re.getTouchPoint(e, this.svg, 0), n = re.getTouchPoint(e, this.svg, 1);
    this.firstDistance = de.calculateDistance(t, n), t.x = (t.x + n.x) / 2, t.y = (t.y + n.y) / 2, this.stateOrigin = t.matrixTransform(this.firstEventCTM.inverse());
  }
};
X.prototype.fit = function() {
  var e = this.viewport.getViewBox(), t = Math.min(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
X.prototype.contain = function() {
  var e = this.viewport.getViewBox(), t = Math.max(
    this.width / e.width,
    this.height / e.height
  );
  this.zoom(t, !0);
};
X.prototype.center = function() {
  var e = this.viewport.getViewBox(), t = (this.width - (e.width + e.x * 2) * this.getZoom()) * 0.5, n = (this.height - (e.height + e.y * 2) * this.getZoom()) * 0.5;
  this.getPublicInstance().pan({ x: t, y: n });
};
X.prototype.updateBBox = function() {
  this.viewport.simpleViewBoxCache();
};
X.prototype.pan = function(e) {
  var t = this.viewport.getCTM();
  t.e = e.x, t.f = e.y, this.viewport.setCTM(t);
};
X.prototype.panBy = function(e) {
  var t = this.viewport.getCTM();
  t.e += e.x, t.f += e.y, this.viewport.setCTM(t);
};
X.prototype.getPan = function() {
  var e = this.viewport.getState();
  return { x: e.x, y: e.y };
};
X.prototype.resize = function() {
  var e = re.getBoundingClientRectNormalized(
    this.svg
  );
  this.width = e.width, this.height = e.height;
  var t = this.viewport;
  t.options.width = this.width, t.options.height = this.height, t.processCTM(), this.options.controlIconsEnabled && (this.getPublicInstance().disableControlIcons(), this.getPublicInstance().enableControlIcons());
};
X.prototype.destroy = function() {
  var e = this;
  this.beforeZoom = null, this.onZoom = null, this.beforePan = null, this.onPan = null, this.onUpdatedCTM = null, this.options.customEventsHandler != null && this.options.customEventsHandler.destroy({
    svgElement: this.svg,
    eventsListenerElement: this.options.eventsListenerElement,
    instance: this.getPublicInstance()
  });
  for (var t in this.eventListeners)
    (this.options.eventsListenerElement || this.svg).removeEventListener(
      t,
      this.eventListeners[t],
      this.options.preventMouseEventsDefault ? no : to
    );
  this.disableMouseWheelZoom(), this.getPublicInstance().disableControlIcons(), Oe = Oe.filter(function(n) {
    return n.svg !== e.svg;
  }), delete this.options, delete this.viewport, delete this.publicInstance, delete this.pi, this.getPublicInstance = function() {
    return null;
  };
};
X.prototype.getPublicInstance = function() {
  var e = this;
  return this.publicInstance || (this.publicInstance = this.pi = {
    // Pan
    enablePan: function() {
      return e.options.panEnabled = !0, e.pi;
    },
    disablePan: function() {
      return e.options.panEnabled = !1, e.pi;
    },
    isPanEnabled: function() {
      return !!e.options.panEnabled;
    },
    pan: function(t) {
      return e.pan(t), e.pi;
    },
    panBy: function(t) {
      return e.panBy(t), e.pi;
    },
    getPan: function() {
      return e.getPan();
    },
    // Pan event
    setBeforePan: function(t) {
      return e.options.beforePan = t === null ? null : de.proxy(t, e.publicInstance), e.pi;
    },
    setOnPan: function(t) {
      return e.options.onPan = t === null ? null : de.proxy(t, e.publicInstance), e.pi;
    },
    // Zoom and Control Icons
    enableZoom: function() {
      return e.options.zoomEnabled = !0, e.pi;
    },
    disableZoom: function() {
      return e.options.zoomEnabled = !1, e.pi;
    },
    isZoomEnabled: function() {
      return !!e.options.zoomEnabled;
    },
    enableControlIcons: function() {
      return e.options.controlIconsEnabled || (e.options.controlIconsEnabled = !0, Nt.enable(e)), e.pi;
    },
    disableControlIcons: function() {
      return e.options.controlIconsEnabled && (e.options.controlIconsEnabled = !1, Nt.disable(e)), e.pi;
    },
    isControlIconsEnabled: function() {
      return !!e.options.controlIconsEnabled;
    },
    // Double click zoom
    enableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !0, e.pi;
    },
    disableDblClickZoom: function() {
      return e.options.dblClickZoomEnabled = !1, e.pi;
    },
    isDblClickZoomEnabled: function() {
      return !!e.options.dblClickZoomEnabled;
    },
    // Mouse wheel zoom
    enableMouseWheelZoom: function() {
      return e.enableMouseWheelZoom(), e.pi;
    },
    disableMouseWheelZoom: function() {
      return e.disableMouseWheelZoom(), e.pi;
    },
    isMouseWheelZoomEnabled: function() {
      return !!e.options.mouseWheelZoomEnabled;
    },
    // Zoom scale and bounds
    setZoomScaleSensitivity: function(t) {
      return e.options.zoomScaleSensitivity = t, e.pi;
    },
    setMinZoom: function(t) {
      return e.options.minZoom = t, e.pi;
    },
    setMaxZoom: function(t) {
      return e.options.maxZoom = t, e.pi;
    },
    // Zoom event
    setBeforeZoom: function(t) {
      return e.options.beforeZoom = t === null ? null : de.proxy(t, e.publicInstance), e.pi;
    },
    setOnZoom: function(t) {
      return e.options.onZoom = t === null ? null : de.proxy(t, e.publicInstance), e.pi;
    },
    // Zooming
    zoom: function(t) {
      return e.publicZoom(t, !0), e.pi;
    },
    zoomBy: function(t) {
      return e.publicZoom(t, !1), e.pi;
    },
    zoomAtPoint: function(t, n) {
      return e.publicZoomAtPoint(t, n, !0), e.pi;
    },
    zoomAtPointBy: function(t, n) {
      return e.publicZoomAtPoint(t, n, !1), e.pi;
    },
    zoomIn: function() {
      return this.zoomBy(1 + e.options.zoomScaleSensitivity), e.pi;
    },
    zoomOut: function() {
      return this.zoomBy(1 / (1 + e.options.zoomScaleSensitivity)), e.pi;
    },
    getZoom: function() {
      return e.getRelativeZoom();
    },
    // CTM update
    setOnUpdatedCTM: function(t) {
      return e.options.onUpdatedCTM = t === null ? null : de.proxy(t, e.publicInstance), e.pi;
    },
    // Reset
    resetZoom: function() {
      return e.resetZoom(), e.pi;
    },
    resetPan: function() {
      return e.resetPan(), e.pi;
    },
    reset: function() {
      return e.reset(), e.pi;
    },
    // Fit, Contain and Center
    fit: function() {
      return e.fit(), e.pi;
    },
    contain: function() {
      return e.contain(), e.pi;
    },
    center: function() {
      return e.center(), e.pi;
    },
    // Size and Resize
    updateBBox: function() {
      return e.updateBBox(), e.pi;
    },
    resize: function() {
      return e.resize(), e.pi;
    },
    getSizes: function() {
      return {
        width: e.width,
        height: e.height,
        realZoom: e.getZoom(),
        viewBox: e.viewport.getViewBox()
      };
    },
    // Destroy
    destroy: function() {
      return e.destroy(), e.pi;
    }
  }), this.publicInstance;
};
var Oe = [], us = function(e, t) {
  var n = de.getSvg(e);
  if (n === null)
    return null;
  for (var o = Oe.length - 1; o >= 0; o--)
    if (Oe[o].svg === n)
      return Oe[o].instance.getPublicInstance();
  return Oe.push({
    svg: n,
    instance: new X(n, t)
  }), Oe[Oe.length - 1].instance.getPublicInstance();
}, ds = us;
const fs = /* @__PURE__ */ ns(ds), hs = {
  getViewArea() {
    const e = this.getSizes(), t = this.getPan(), n = e.realZoom;
    t.x /= n, t.y /= n;
    const o = {
      width: e.width / n,
      height: e.height / n
    };
    return {
      box: {
        top: -t.y,
        bottom: o.height - t.y,
        left: -t.x,
        right: o.width - t.x
      },
      center: {
        x: o.width / 2 - t.x,
        y: o.height / 2 - t.y
      }
    };
  },
  getViewBox() {
    return this.getViewArea().box;
  },
  setViewBox(e) {
    const t = e.right - e.left, n = e.bottom - e.top, { width: o, height: i } = this.getSizes(), s = t / n, r = o / i, a = s < r ? n * r : t, c = s > r ? t / r : n, d = Math.min(
      o / a,
      i / c
    ), u = this.getRealZoom(), h = this.getZoom(), l = u / h;
    this.zoom(d / l);
    const p = {
      x: (e.left + t / 2) * d,
      y: (e.top + n / 2) * d
    };
    this.pan({
      x: -p.x + a / 2 * d,
      y: -p.y + c / 2 * d
    });
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(e, t, n) {
    const o = Math.max(1e-4, t), i = Math.max(o, n), s = Math.max(Math.min(i, e), o), r = this.getRealZoom(), a = this.getZoom(), c = r / a;
    this.setMinZoom(o / c).setMaxZoom(i / c).zoom(s / c);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    return this._isPanEnabled = !0, this._internalEnablePan(), this;
  },
  disablePan() {
    return this._isPanEnabled = !1, this._internalDisablePan(), this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    return this._isZoomEnabled = !0, this._internalEnableZoom(), this;
  },
  disableZoom() {
    return this._isZoomEnabled = !1, this._internalDisableZoom(), this;
  },
  setPanEnabled(e) {
    return e ? this.enablePan() : this.disablePan(), this;
  },
  setZoomEnabled(e) {
    return e ? (this.enableZoom(), this.enableDblClickZoom()) : (this.disableZoom(), this.disableDblClickZoom()), this;
  }
};
function ps(e, t) {
  var o, i;
  const n = e;
  return n._isPanEnabled = (o = t.panEnabled) != null ? o : !0, n._isZoomEnabled = (i = t == null ? void 0 : t.zoomEnabled) != null ? i : !0, n._internalIsPanEnabled = n.isPanEnabled, n._internalEnablePan = n.enablePan, n._internalDisablePan = n.disablePan, n._internalIsZoomEnabled = n.isZoomEnabled, n._internalEnableZoom = n.enableZoom, n._internalDisableZoom = n.disableZoom, Object.assign(e, hs), n;
}
function vs(e, t) {
  var s, r, a, c, d, u;
  const n = (r = (s = t.customEventsHandler) == null ? void 0 : s.init) != null ? r : (h) => {
  }, o = (c = (a = t.customEventsHandler) == null ? void 0 : a.destroy) != null ? c : (h) => {
  }, i = (u = (d = t.customEventsHandler) == null ? void 0 : d.haltEventListeners) != null ? u : [];
  return t.mouseWheelZoomEnabled === void 0 && (t.mouseWheelZoomEnabled = t.zoomEnabled), t.customEventsHandler = {
    init: (h) => {
      ps(h.instance, t), n(h);
    },
    destroy: (h) => o(h),
    haltEventListeners: i
  }, fs(e, t);
}
function gs(e, t) {
  const n = j();
  let o = 0;
  const i = [], s = [], r = () => {
    o = 1, i.forEach((u) => u()), i.length = 0;
  }, a = () => {
    o = 2, s.forEach((u) => u()), s.length = 0;
  };
  return Ue(() => {
    var k, y, v, b, E, g;
    const u = q(e.value, "<svg>"), h = (y = (k = t.customEventsHandler) == null ? void 0 : k.init) != null ? y : (f) => {
    }, l = (b = (v = t.customEventsHandler) == null ? void 0 : v.destroy) != null ? b : (f) => {
    }, p = (g = (E = t.customEventsHandler) == null ? void 0 : E.haltEventListeners) != null ? g : [];
    t.customEventsHandler = {
      init: (f) => {
        n.value = f.instance, h(f), r();
      },
      destroy: (f) => {
        a(), l(f);
      },
      haltEventListeners: p
    };
    const w = () => {
      const f = u.getBoundingClientRect();
      f.width !== 0 && f.height !== 0 ? vs(u, t) : setTimeout(w, 200);
    };
    w();
  }), et(() => {
    var u;
    (u = n.value) == null || u.destroy(), n.value = void 0;
  }), { svgPanZoom: n, onSvgPanZoomMounted: (u) => {
    o === 0 ? i.push(u) : o === 1 && u();
  }, onSvgPanZoomUnmounted: (u) => {
    o === 0 || o === 1 ? s.push(u) : u();
  } };
}
const oo = Symbol("zoomLevel");
function ms(e, t) {
  const n = O(() => t.scalingObjects ? 1 : 1 / e.value);
  return $e(oo, {
    zoomLevel: e,
    scale: n
  }), { scale: n };
}
function ge() {
  return q(Le(oo), "zoomLevel");
}
function bs(e) {
  return e instanceof Promise || e && typeof e.then == "function";
}
function ys() {
  let e = null;
  const t = j({
    enabled: !1,
    duration: 300,
    timingFunction: "linear"
  });
  function n(o, i = 300, s = "linear") {
    e && (clearTimeout(e), e = null), t.value = {
      enabled: !0,
      duration: i,
      timingFunction: s
    }, jt(() => ye(this, null, function* () {
      const r = o();
      bs(r) && (yield r), e && clearTimeout(e), e = window == null ? void 0 : window.setTimeout(() => {
        t.value.enabled = !1, e = null;
      }, i);
    }));
  }
  return { transitionWhile: n, transitionOption: t };
}
function ws(e) {
  const t = j({}), n = j(!1);
  let o = 1;
  const i = /* @__PURE__ */ new Map();
  return ve(() => {
    if (e.value instanceof Array) {
      const s = /* @__PURE__ */ new Set([]);
      if (t.value = Object.fromEntries(
        e.value.map((r) => {
          let a = r.id;
          return a || (n.value || (n.value = !0, console.warn(
            "[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required."
          )), a = i.get(r), a || (a = "path-" + o++, i.set(r, a))), s.add(a), [a, r];
        })
      ), n.value)
        for (const [r, a] of Array.from(i.entries()))
          s.has(a) || i.delete(r);
    } else
      t.value = e.value;
  }), { objects: t, isInCompatibilityModeForPath: n };
}
function Es(e, t, n, o) {
  if (o) {
    const s = j(o(e[t])), r = (a) => {
      Te(a, s.value) || (s.value = a), Te(a, e[t]) || n(`update:${t}`, a);
    };
    return U(() => o(s.value), r), U(() => e[t], (a) => r(o(a))), s.value !== e[t] && n(`update:${t}`, s.value), s;
  }
  const i = j(e[t]);
  return U(
    () => e[t],
    (s) => {
      Te(s, i.value) || (i.value = s);
    }
  ), U(i, (s) => {
    Te(s, e[t]) || n(`update:${t}`, s);
  }), i;
}
function Tt(e, t, n, o) {
  const i = Me(/* @__PURE__ */ new Set());
  return U(
    () => e[t],
    () => {
      const r = e[t].filter((a) => a in n.value);
      Te(r, Array.from(i)) || (i.clear(), r.forEach(i.add, i));
    },
    { deep: !0, immediate: !0 }
  ), U(i, () => {
    const s = Array.from(i);
    Te(e[t], s) || o(`update:${t}`, s);
  }), ze(i);
}
const io = Symbol("selection");
function ks(e, t, n) {
  $e(io, {
    selectedNodes: e,
    selectedEdges: t,
    selectedPaths: n
  });
}
function xs() {
  return q(Le(io), "Selections");
}
const so = Symbol("layouts");
function Ps(e) {
  $e(so, e);
}
function en() {
  return q(Le(so), "Layouts");
}
function Ss(e, t) {
  for (let n = 0; n < e.length - 1; n++)
    t(e[n], e[n + 1]);
}
function Ke(e, t) {
  const n = e.indexOf(t);
  n >= 0 && e.splice(n, 1);
}
function Ms(e, t, n) {
  const o = e.indexOf(t);
  o < 0 || e.splice(o + 1, 0, n);
}
function Cs(e, t) {
  const n = [
    "edges",
    "edge-labels",
    "focusring",
    "nodes",
    "node-labels",
    "paths"
  ];
  return O(() => {
    const o = Uo(e.view.builtInLayerOrder).filter((s) => {
      const r = n.includes(s);
      return r || console.warn(`Layer ${s} is not a built-in layer.`), r;
    }).reverse(), i = [...n];
    return Ss(o, (s, r) => {
      Ke(i, r), Ms(i, s, r);
    }), "edge-label" in t || "edges-label" in t || Ke(i, "edge-labels"), e.node.focusring.visible || Ke(i, "focusring"), e.node.label.visible === !1 && Ke(i, "node-labels"), e.path.visible || Ke(i, "paths"), i;
  });
}
const Sn = () => new Promise((e) => jt(e));
function Os(e, t) {
  const n = Math.max(e.width, e.height, t.width, t.height) / 1e4;
  return Math.abs(e.x - t.x) < n && Math.abs(e.y - t.y) < n && Math.abs(e.width - t.width) < n && Math.abs(e.height - t.height) < n;
}
function zs(e, t) {
  return {
    top: e.top + t.top,
    left: e.left + t.left,
    right: e.right + t.right,
    bottom: e.bottom + t.bottom
  };
}
function Ts(e, t) {
  return {
    top: e.top * t,
    left: e.left * t,
    right: e.right * t,
    bottom: e.bottom * t
  };
}
function _s(e, t) {
  return {
    top: e.top / t,
    left: e.left / t,
    right: e.right / t,
    bottom: e.bottom / t
  };
}
function ro(e) {
  return {
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function ao(e) {
  return {
    x: e.left,
    y: e.top,
    width: e.right - e.left,
    height: e.bottom - e.top
  };
}
function Is(e, t) {
  return {
    top: Math.min(e.top, t.top),
    left: Math.min(e.left, t.left),
    right: Math.max(e.right, t.right),
    bottom: Math.max(e.bottom, t.bottom)
  };
}
const $s = new RegExp("^\\d+$");
function Ls(e, t) {
  let n = { top: 0, left: 0, right: 0, bottom: 0 };
  if (typeof e == "string") {
    const o = Ve(e, t.width), i = Ve(e, t.height);
    o === void 0 || i === void 0 ? console.warn("Invalid `fitContentMargin` value.", e) : n = { top: i, left: o, right: o, bottom: i };
  } else if (typeof e == "number") {
    const o = e;
    n = { top: o, left: o, right: o, bottom: o };
  } else {
    if (e.top) {
      const o = Ve(e.top, t.height);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.top) : n.top = o;
    }
    if (e.left) {
      const o = Ve(e.left, t.width);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.left) : n.left = o;
    }
    if (e.right) {
      const o = Ve(e.right, t.width);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.right) : n.right = o;
    }
    if (e.bottom) {
      const o = Ve(e.bottom, t.height);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", e.bottom) : n.bottom = o;
    }
  }
  return n;
}
function As(e, t, n, o, i, s) {
  const r = e.getBBox();
  if (s)
    return Ds(r, t, n, i);
  {
    const a = Zs(e);
    return Ns(
      r,
      a,
      t,
      n,
      o,
      i
    );
  }
}
function Ve(e, t) {
  if (typeof e == "string") {
    if (e.endsWith("%")) {
      const n = parseInt(e.toString());
      if (Number.isFinite(n))
        return t * (n / 100);
    } else if (e.endsWith("px") || $s.test(e)) {
      const n = parseInt(e.toString());
      if (Number.isFinite(n))
        return n;
    }
  } else if (typeof e == "number")
    return e;
}
function Zs(e) {
  return Array.from(e.querySelectorAll(".v-ng-graph-objects")).map(
    (n) => n.getBBox()
  ).reduce(
    (n, o, i) => {
      if (i === 0) return o;
      const s = Math.min(n.x, o.x), r = Math.min(n.y, o.y);
      return {
        x: s,
        y: r,
        width: Math.max(n.x + n.width - s, o.x + o.width - s),
        height: Math.max(n.y + n.height - r, o.y + o.height - r)
      };
    },
    { x: 0, y: 0, width: 0, height: 0 }
  );
}
function Ds(e, t, n, o) {
  if (Object.keys(n).length <= 1)
    return;
  const i = lo(e, t, o);
  if (i > 0) {
    const s = ro(e);
    return {
      zoom: i,
      pos: co(s, i, t, o)
    };
  } else
    return;
}
function Ns(e, t, n, o, i, s) {
  if (Object.keys(o).length <= 1)
    return;
  const r = vi(o), a = {
    top: (r.top - t.y) * i,
    left: (r.left - t.x) * i,
    right: (t.x + t.width - r.right) * i,
    bottom: (t.y + t.height - r.bottom) * i
  };
  let c = lo(e, n, s);
  if (c === 0)
    return;
  const d = ft(n, zs(s, a));
  if (d.width <= 0 || d.height <= 0)
    return;
  const u = ro(e), h = ft(n, s), l = Os(e, t);
  let p = 0, w = 0, k = { top: 0, left: 0, right: 0, bottom: 0 };
  do {
    w = c;
    const y = _s(a, c), v = {
      top: r.top - y.top,
      left: r.left - y.left,
      right: r.right + y.right,
      bottom: r.bottom + y.bottom
    };
    k = l ? v : Is(u, v);
    const b = ao(k), g = [h.width / b.width, h.height / b.height].filter((f) => f > 0);
    if (g.length === 0)
      return;
    c = Math.min(...g), p++;
  } while (Math.abs(w - c) > 1e-6 && p < 10);
  return {
    zoom: c,
    pos: co(k, c, n, s)
  };
}
function lo(e, t, n) {
  if (e.width === 0 || e.height === 0) return 0;
  const o = ft(t, n);
  if (o.width <= 0 || o.height <= 0)
    return 0;
  const i = [o.width / e.width, o.height / e.height];
  return Math.min(...i);
}
function co(e, t, n, o) {
  const i = ft(n, o), s = ao(Ts(e, t)), r = (i.width - s.width) / 2, a = (i.height - s.height) / 2, c = s.x - o.left, d = s.y - o.top;
  return {
    x: -c + r,
    y: -d + a
  };
}
function ft(e, t) {
  const n = t.left + t.right, o = t.top + t.bottom;
  return {
    width: e.width - n,
    height: e.height - o
  };
}
const js = ["x", "y", "width", "height", "fill", "stroke", "stroke-width", "stroke-dasharray"], Bs = /* @__PURE__ */ F({
  __name: "VSelectionBox",
  props: {
    box: {},
    config: {}
  },
  setup(e) {
    return (t, n) => (S(), I("rect", {
      class: "v-ng-selection-box",
      x: Math.round(t.box.pos.x),
      y: Math.round(t.box.pos.y),
      width: Math.ceil(t.box.size.width),
      height: Math.ceil(t.box.size.height),
      fill: t.config.color,
      stroke: t.config.strokeColor,
      "stroke-width": t.config.strokeWidth,
      "stroke-dasharray": t.config.strokeDasharray
    }, null, 8, js));
  }
}), Rs = ["points", "fill"], Vs = /* @__PURE__ */ F({
  __name: "VMarkerHeadArrow",
  props: {
    width: {},
    height: {},
    refX: {},
    color: {},
    isSource: { type: Boolean },
    units: {}
  },
  setup(e) {
    const t = e, n = O(() => {
      const o = t.width, i = t.height;
      return t.isSource ? `${o} ${i}, 0 ${i / 2}, ${o} 0` : `0 0, ${o} ${i / 2}, 0 ${i}`;
    });
    return (o, i) => (S(), I("polygon", {
      points: n.value,
      fill: o.color
    }, null, 8, Rs));
  }
}), Ws = ["points", "stroke-width", "stroke"], Hs = /* @__PURE__ */ F({
  __name: "VMarkerHeadAngle",
  props: {
    width: {},
    height: {},
    refX: {},
    color: {},
    isSource: { type: Boolean },
    units: {}
  },
  setup(e) {
    const t = e, n = O(() => t.units === "strokeWidth" ? 1 : Math.min(t.width, t.height) / 5), o = O(() => {
      const i = n.value / 2, s = t.width, r = t.height;
      return t.isSource ? `${s - i} ${r - i}, ${i} ${r / 2}, ${s - i} ${i}` : `${i} ${i}, ${s - i} ${r / 2}, ${i} ${r - i}`;
    });
    return (i, s) => (S(), I("polyline", {
      points: o.value,
      fill: "none",
      "stroke-width": n.value,
      stroke: i.color,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, 8, Ws));
  }
}), Fs = ["fill", "cx", "cy", "rx", "ry"], Us = /* @__PURE__ */ F({
  __name: "VMarkerHeadCircle",
  props: {
    width: {},
    height: {},
    refX: {},
    color: {},
    isSource: { type: Boolean },
    units: {}
  },
  setup(e) {
    return (t, n) => (S(), I("ellipse", {
      fill: t.color,
      cx: t.width / 2,
      cy: t.height / 2,
      rx: t.width / 2,
      ry: t.height / 2
    }, null, 8, Fs));
  }
}), Xs = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"], qs = /* @__PURE__ */ F({
  __name: "VMarkerHead",
  props: {
    id: {},
    marker: {},
    scale: {}
  },
  setup(e) {
    const t = {
      arrow: Vs,
      angle: Hs,
      circle: Us
    }, n = e, o = O(
      () => n.marker.width * (n.marker.units === "strokeWidth" ? 1 : n.scale)
    ), i = O(
      () => n.marker.height * (n.marker.units === "strokeWidth" ? 1 : n.scale)
    ), s = O(() => {
      const a = n.marker.margin * (n.marker.units === "strokeWidth" ? 1 : n.scale);
      return n.marker.isSource ? o.value + a : -a;
    }), r = O(() => {
      const a = n.marker.offset * (n.marker.units === "strokeWidth" ? 1 : n.scale);
      return n.marker.isSource ? a : -a;
    });
    return (a, c) => a.marker.type !== "none" && a.marker.type !== "custom" ? (S(), I("marker", {
      key: 0,
      id: a.id,
      markerWidth: o.value,
      markerHeight: i.value,
      refX: s.value,
      refY: i.value / 2 + r.value,
      orient: "auto",
      markerUnits: a.marker.units,
      class: "v-ng-marker"
    }, [
      (S(), W(zn(t[a.marker.type]), {
        width: o.value,
        height: i.value,
        refX: s.value,
        color: a.marker.color,
        "is-source": a.marker.isSource,
        units: a.marker.units
      }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
    ], 8, Xs)) : ue("", !0);
  }
}), Gs = {
  class: "v-ng-background-grid",
  "shape-rendering": "crispEdges"
}, Ks = ["d"], Ys = ["d"], Qs = ["d"], Js = ["d"], er = /* @__PURE__ */ F({
  __name: "VBackgroundGrid",
  setup(e) {
    const { container: t, svgPanZoom: n } = Vt(), { zoomLevel: o } = ge(), i = ts(), s = Qo(), r = j({ x: 0, y: 0 }), a = j({ width: 500, height: 500 });
    Ue(() => {
      var w;
      const l = (w = n.value) == null ? void 0 : w.getPan();
      l && (r.value = {
        x: -l.x,
        y: -l.y
      });
      const p = t.value.getBoundingClientRect();
      a.value = {
        width: p.width,
        height: p.height
      };
    }), i.on("view:resize", (l) => {
      a.value = { width: l.width, height: l.height };
    }), i.on("view:pan", (l) => {
      r.value = { x: -l.x, y: -l.y };
    }), i.on("view:zoom", () => {
      var p;
      const l = (p = n.value) == null ? void 0 : p.getPan();
      l && (r.value = { x: -l.x, y: -l.y });
    });
    const c = j([]), d = j([]), u = j([]), h = j([]);
    return ve(() => {
      const l = [], p = [], w = [], k = [], y = 1 / o.value, v = s.grid.interval, b = r.value.x * y, E = r.value.y * y, g = Math.floor(a.value.width / v + 1) * v, f = Math.floor(a.value.height / v + 1) * v, m = (r.value.x + g) * y, x = (r.value.y + f) * y, z = s.grid.thickIncrements, $ = s.grid.line.dasharray, C = s.grid.thick.dasharray;
      let T = {
        stroke: s.grid.thick.color,
        "stroke-width": s.grid.thick.width,
        "stroke-dasharray": C,
        "stroke-dashoffset": C ? b / y : void 0
      }, L = {
        stroke: s.grid.line.color,
        "stroke-width": s.grid.line.width,
        "stroke-dasharray": $,
        "stroke-dashoffset": $ ? b / y : void 0
      };
      const N = (r.value.x + g) * y;
      for (let B = E; B <= x; B += v) {
        const H = Math.floor(B / v);
        z && H % z === 0 ? l.push([H, H * v, b, N, T]) : w.push([H, H * v, b, N, L]);
      }
      T = se({}, T), T["stroke-dashoffset"] = C ? E / y : void 0, L = se({}, L), L["stroke-dashoffset"] = $ ? E / y : void 0;
      const K = (r.value.y + f) * y;
      for (let B = b; B <= m; B += v) {
        const H = Math.floor(B / v);
        z && H % z === 0 ? p.push([H, H * v, E, K, T]) : k.push([H, H * v, E, K, L]);
      }
      d.value = l, c.value = p, h.value = w, u.value = k;
    }), (l, p) => (S(), I("g", Gs, [
      (S(!0), I(G, null, J(h.value, ([w, k, y, v, b]) => (S(), I("path", oe({
        key: `nv${w}`,
        d: `M ${y} ${k} L ${v} ${k}`,
        ref_for: !0
      }, b, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Ks))), 128)),
      (S(!0), I(G, null, J(u.value, ([w, k, y, v, b]) => (S(), I("path", oe({
        key: `nh${w}`,
        d: `M ${k} ${y} L ${k} ${v}`,
        ref_for: !0
      }, b, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Ys))), 128)),
      (S(!0), I(G, null, J(d.value, ([w, k, y, v, b]) => (S(), I("path", oe({
        key: `tv${w}`,
        d: `M ${y} ${k} L ${v} ${k}`,
        ref_for: !0
      }, b, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Qs))), 128)),
      (S(!0), I(G, null, J(c.value, ([w, k, y, v, b]) => (S(), I("path", oe({
        key: `th${w}`,
        d: `M ${k} ${y} L ${k} ${v}`,
        ref_for: !0
      }, b, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Js))), 128))
    ]));
  }
}), tr = /* @__PURE__ */ F({
  __name: "VBackgroundViewport",
  setup(e) {
    const { viewport: t } = Vt(), n = j(), o = (s, r, a) => {
      s.forEach((c) => {
        var d;
        return r.setAttribute(c, (d = a.getAttribute(c)) != null ? d : "");
      });
    }, i = new MutationObserver((s) => {
      if (!n.value) return;
      const r = s.map((a) => {
        var c;
        return (c = a.attributeName) != null ? c : "";
      }).filter(Boolean);
      o(r, n.value, t.value);
    });
    return Ue(() => {
      const s = ["transform", "style"];
      i.observe(t.value, {
        attributes: !0,
        attributeFilter: s
      }), n.value && o(s, n.value, t.value);
    }), et(() => {
      i.disconnect();
    }), (s, r) => (S(), I("g", {
      ref_key: "background",
      ref: n,
      class: "v-ng-background-viewport"
    }, [
      Y(s.$slots, "default")
    ], 512));
  }
}), nr = ["d", "stroke-width"], or = /* @__PURE__ */ F({
  __name: "VEdgeBackground",
  props: {
    id: {},
    state: {},
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = ge(), o = mt(), {
      handleEdgePointerDownEvent: i,
      handleEdgePointerOverEvent: s,
      handleEdgePointerOutEvent: r,
      handleEdgeClickEvent: a,
      handleEdgeDoubleClickEvent: c,
      handleEdgeContextMenu: d
    } = ot(), u = O(() => {
      const l = t.state.position;
      if (t.state.loop) {
        const { radius: p, isLargeArc: w, isClockwise: k } = t.state.loop, [y, v] = p, b = w ? 1 : 0, E = k ? 1 : 0;
        return `M ${l.p1.x} ${l.p1.y} A ${y} ${v} 0 ${b} ${E} ${l.p2.x} ${l.p2.y}`;
      } else {
        if (o.type === "straight" || !t.state.curve)
          return `M ${l.p1.x} ${l.p1.y} L ${l.p2.x} ${l.p2.y}`;
        {
          const p = [...t.state.curve.control, { x: l.p2.x, y: l.p2.y }], w = [];
          return w.push(`M ${l.p1.x} ${l.p1.y}`), Rt(p, 2).forEach(([k, y]) => w.push(`Q ${k.x} ${k.y} ${y.x} ${y.y}`)), w.join(" ");
        }
      }
    }), h = O(() => (t.state.line.stroke.width + 10) * n.value);
    return (l, p) => (S(), I("path", {
      class: he({ "v-ng-line-background": !0, selectable: l.state.selectable }),
      d: u.value,
      stroke: "transparent",
      "stroke-width": h.value,
      fill: "none",
      onPointerdown: p[0] || (p[0] = we((w) => M(i)(l.id, w), ["stop"])),
      onPointerenterPassive: p[1] || (p[1] = (w) => M(s)(l.id, w)),
      onPointerleavePassive: p[2] || (p[2] = (w) => M(r)(l.id, w)),
      onClick: p[3] || (p[3] = we((w) => M(a)(l.id, w), ["stop"])),
      onDblclick: p[4] || (p[4] = we((w) => M(c)(l.id, w), ["stop"])),
      onContextmenu: p[5] || (p[5] = (w) => M(d)(l.id, w))
    }, null, 42, nr));
  }
}), ir = /* @__PURE__ */ F({
  __name: "VEdgeBackgrounds",
  setup(e) {
    const { edgeStates: t, edgeGroupStates: n, layouts: o } = ke();
    return (i, s) => (S(!0), I(G, null, J(M(n).edgeGroups, ({ summarize: r, edges: a }) => (S(), I(G, null, [
      r ? ue("", !0) : (S(!0), I(G, { key: 0 }, J(a, (c, d) => (S(), W(or, {
        key: d,
        id: d,
        state: M(t)[d],
        "source-pos": M(o).nodes[c.source],
        "target-pos": M(o).nodes[c.target]
      }, null, 8, ["id", "state", "source-pos", "target-pos"]))), 128))
    ], 64))), 256));
  }
}), sr = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], uo = /* @__PURE__ */ F({
  __name: "VLine",
  props: {
    p1: {},
    p2: {},
    config: {}
  },
  setup(e) {
    const t = e, { scale: n } = ge(), o = O(() => t.config.width * n.value), i = O(() => nt(t.config.dasharray, n.value)), s = O(() => {
      const r = t.config.animate ? pt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return r ? { "--animation-speed": r } : void 0;
    });
    return (r, a) => (S(), I("path", {
      class: he({ "v-ng-line": !0, animate: r.config.animate }),
      d: `M ${r.p1.x} ${r.p1.y} L ${r.p2.x} ${r.p2.y}`,
      stroke: r.config.color,
      "stroke-width": o.value,
      "stroke-dasharray": i.value,
      "stroke-linecap": r.config.linecap,
      style: tt(s.value)
    }, null, 14, sr));
  }
}), rr = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], ar = /* @__PURE__ */ F({
  __name: "VArc",
  props: {
    p1: {},
    p2: {},
    radius: {},
    isLargeArc: { type: Boolean },
    isClockwise: { type: Boolean },
    config: {}
  },
  setup(e) {
    const t = e, { scale: n } = ge(), o = O(() => t.config.width * n.value), i = O(() => nt(t.config.dasharray, n.value)), s = O(() => {
      const a = t.config.animate ? pt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? { "--animation-speed": a } : void 0;
    }), r = O(() => {
      const { p1: a, p2: c, radius: d, isLargeArc: u, isClockwise: h } = t, [l, p] = d, w = u ? 1 : 0, k = h ? 1 : 0;
      return `M ${a.x} ${a.y} A ${l} ${p} 0 ${w} ${k} ${c.x} ${c.y}`;
    });
    return (a, c) => (S(), I("path", {
      class: he({ "v-ng-line": !0, animate: a.config.animate }),
      d: r.value,
      stroke: a.config.color,
      "stroke-width": o.value,
      "stroke-dasharray": i.value,
      "stroke-linecap": a.config.linecap,
      style: tt(s.value),
      fill: "none"
    }, null, 14, rr));
  }
}), lr = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"], cr = /* @__PURE__ */ F({
  __name: "VEdgeCurved",
  props: {
    state: {},
    config: {},
    markerStart: { default: void 0 },
    markerEnd: { default: void 0 }
  },
  setup(e) {
    const t = e, { scale: n } = ge(), o = O(() => {
      var u, h;
      const a = t.state.position, c = [...(h = (u = t.state.curve) == null ? void 0 : u.control) != null ? h : [], { x: a.p2.x, y: a.p2.y }], d = [];
      return d.push(`M ${a.p1.x} ${a.p1.y}`), Rt(c, 2).forEach(([l, p]) => d.push(`Q ${l.x} ${l.y} ${p.x} ${p.y}`)), d.join(" ");
    }), i = O(() => t.config.width * n.value), s = O(() => nt(t.config.dasharray, n.value)), r = O(() => {
      const a = t.config.animate ? pt(t.config.dasharray) * t.config.animationSpeed * n.value : !1;
      return a ? { "--animation-speed": a } : void 0;
    });
    return (a, c) => (S(), I("path", {
      class: he({ "v-ng-line": !0, animate: a.config.animate }),
      d: o.value,
      fill: "none",
      stroke: a.config.color,
      "stroke-width": i.value,
      "stroke-dasharray": s.value,
      "stroke-linecap": a.config.linecap,
      style: tt(r.value),
      "marker-start": a.markerStart,
      "marker-end": a.markerEnd
    }, null, 14, lr));
  }
}), ur = /* @__PURE__ */ F({
  __name: "VEdge",
  props: {
    id: {},
    state: {},
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(e) {
    const t = mt();
    return (n, o) => n.state.loop ? (S(), W(ar, oe({ key: 0 }, n.state.position, {
      radius: n.state.loop.radius,
      "is-large-arc": n.state.loop.isLargeArc,
      "is-clockwise": n.state.loop.isClockwise,
      class: [{ selectable: n.state.selectable, hover: n.state.hovered, selected: n.state.selected }, "v-ng-edge"],
      config: n.state.line.stroke,
      "marker-start": n.state.sourceMarkerId ? `url('#${n.state.sourceMarkerId}')` : void 0,
      "marker-end": n.state.targetMarkerId ? `url('#${n.state.targetMarkerId}')` : void 0
    }), null, 16, ["radius", "is-large-arc", "is-clockwise", "class", "config", "marker-start", "marker-end"])) : M(t).type == "straight" || !n.state.curve ? (S(), W(uo, oe({
      key: 1,
      "data-edge-id": n.id
    }, n.state.position, {
      class: [{ selectable: n.state.selectable, hover: n.state.hovered, selected: n.state.selected }, "v-ng-edge"],
      config: n.state.line.stroke,
      "marker-start": n.state.sourceMarkerId ? `url('#${n.state.sourceMarkerId}')` : void 0,
      "marker-end": n.state.targetMarkerId ? `url('#${n.state.targetMarkerId}')` : void 0
    }), null, 16, ["data-edge-id", "class", "config", "marker-start", "marker-end"])) : (S(), W(cr, {
      key: 2,
      "data-edge-id": n.id,
      class: he([{ selectable: n.state.selectable, hover: n.state.hovered, selected: n.state.selected }, "v-ng-edge"]),
      state: n.state,
      config: n.state.line.stroke,
      "marker-start": n.state.sourceMarkerId ? `url('#${n.state.sourceMarkerId}')` : void 0,
      "marker-end": n.state.targetMarkerId ? `url('#${n.state.targetMarkerId}')` : void 0
    }, null, 8, ["data-edge-id", "class", "state", "config", "marker-start", "marker-end"]));
  }
}), dr = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"], fr = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"], wt = /* @__PURE__ */ F({
  __name: "VShape",
  props: {
    baseX: { default: 0 },
    baseY: { default: 0 },
    config: {}
  },
  setup(e) {
    const t = e, { scale: n } = ge(), o = j(t.baseX), i = j(t.baseY), s = j(0), r = j("#000000"), a = j(void 0), c = j(0), d = j(0), u = j(0), h = j(0);
    return ve(() => {
      var p;
      const l = n.value;
      s.value = t.config.strokeWidth * l, r.value = (p = t.config.strokeColor) != null ? p : "none", a.value = nt(t.config.strokeDasharray, l), t.config.type === "circle" ? (o.value = t.baseX, i.value = t.baseY, c.value = t.config.radius * l) : (d.value = t.config.width * l, u.value = t.config.height * l, h.value = t.config.borderRadius * l, o.value = t.baseX - d.value / 2, i.value = t.baseY - u.value / 2);
    }), (l, p) => l.config.type === "circle" ? (S(), I("circle", {
      key: 0,
      class: "v-ng-shape-circle",
      cx: o.value,
      cy: i.value,
      r: c.value,
      fill: l.config.color,
      stroke: r.value,
      "stroke-width": s.value,
      "stroke-dasharray": a.value
    }, null, 8, dr)) : (S(), I("rect", {
      key: 1,
      class: "v-ng-shape-rect",
      x: o.value,
      y: i.value,
      width: d.value,
      height: u.value,
      rx: h.value,
      ry: h.value,
      fill: l.config.color,
      stroke: r.value,
      "stroke-width": s.value,
      "stroke-dasharray": a.value
    }, null, 8, fr));
  }
}), hr = ["rx", "ry", "fill", "transform"], pr = ["x", "y", "dominant-baseline", "font-family", "font-size", "fill"], vr = ["x", "dy", "dominant-baseline"], Et = /* @__PURE__ */ F({
  __name: "VLabelText",
  props: {
    text: {},
    x: { default: 0 },
    y: { default: 0 },
    dominantBaseline: { default: "central" },
    config: {}
  },
  setup(e) {
    const t = e, n = Bo(), { scale: o } = ge(), i = O(() => {
      var y, v;
      return (v = (y = t.text) == null ? void 0 : y.toString().split(/\r?\n/)) != null ? v : "";
    }), s = O(() => {
      var y;
      return (y = n["font-size"]) != null ? y : t.config.fontSize * o.value;
    }), r = O(() => s.value * t.config.lineHeight), a = O(() => {
      const y = t.dominantBaseline;
      return y === "hanging" ? 0 : y === "central" ? -(r.value * (i.value.length - 1)) / 2 : -r.value * (i.value.length - 1);
    }), c = j(), d = j(""), u = Me({ x: 0, y: 0, width: 0, height: 0 }), h = O(() => {
      var g, f;
      const y = t.config.background;
      if (!y) return u;
      let v, b;
      y.padding instanceof Object ? (v = y.padding.vertical, b = y.padding.horizontal) : (v = (g = y.padding) != null ? g : 0, b = (f = y.padding) != null ? f : 0);
      const E = r.value - s.value;
      return {
        x: u.x - b * o.value,
        y: u.y - v * o.value - E / 2,
        width: u.width + b * 2 * o.value,
        height: u.height + v * 2 * o.value + E
      };
    });
    let l;
    const p = () => {
      t.config.background && t.config.background.visible ? !l && c.value && (l = k(c.value, u, d)) : (l == null || l.disconnect(), l = void 0);
    };
    Ue(() => p()), U(
      () => t.config.background && t.config.background.visible,
      (y, v) => {
        y != v && p();
      }
    ), et(() => {
      l == null || l.disconnect(), l = void 0;
    });
    function w(y, v, b) {
      var g;
      const E = y.getBBox();
      v.x = E.x, v.y = E.y, v.width = E.width, v.height = E.height, b.value = (g = y.getAttribute("transform")) != null ? g : void 0;
    }
    function k(y, v, b) {
      const E = new MutationObserver(() => {
        w(y, v, b);
      });
      return E.observe(y, {
        attributes: !0,
        attributeFilter: ["x", "y", "transform", "font-size"]
      }), w(y, v, b), E;
    }
    return (y, v) => {
      var b, E, g, f, m, x;
      return S(), I(G, null, [
        y.config.background && y.config.background.visible ? (S(), I("rect", oe({
          key: 0,
          class: "v-ng-text-background"
        }, h.value, {
          rx: ((E = (b = y.config.background) == null ? void 0 : b.borderRadius) != null ? E : 0) * M(o),
          ry: ((f = (g = y.config.background) == null ? void 0 : g.borderRadius) != null ? f : 0) * M(o),
          fill: (x = (m = y.config.background) == null ? void 0 : m.color) != null ? x : "#ffffff",
          transform: d.value
        }), null, 16, hr)) : ue("", !0),
        Tn("text", oe({
          ref_key: "element",
          ref: c,
          class: "v-ng-text"
        }, y.$attrs, {
          x: y.x,
          y: y.y,
          "dominant-baseline": y.dominantBaseline,
          "font-family": y.$attrs["font-family"] ? `${y.$attrs["font-family"]}` : y.config.fontFamily,
          "font-size": s.value,
          fill: y.$attrs.fill ? `${y.$attrs.fill}` : y.config.color
        }), [
          i.value.length <= 1 ? (S(), I(G, { key: 0 }, [
            Ro(un(y.text), 1)
          ], 64)) : (S(!0), I(G, { key: 1 }, J(i.value, (z, $) => (S(), I("tspan", {
            key: $,
            x: y.x,
            dy: $ == 0 ? a.value : r.value,
            "dominant-baseline": y.dominantBaseline
          }, un(z), 9, vr))), 128))
        ], 16, pr)
      ], 64);
    };
  }
}), gr = /* @__PURE__ */ F({
  __name: "VEdgeSummarized",
  props: {
    edges: {},
    layouts: {}
  },
  setup(e) {
    const t = e, n = mt(), {
      handleEdgesPointerDownEvent: o,
      handleEdgesPointerOverEvent: i,
      handleEdgesPointerOutEvent: s,
      handleEdgesClickEvent: r,
      handleEdgesDoubleClickEvent: a,
      handleEdgesContextMenu: c
    } = ot(), { edgeStates: d } = ke(), u = j({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }), h = j({ x: 0, y: 0 });
    ve(() => {
      const E = Object.keys(t.edges).find((g) => g in d);
      E && (u.value = d[E].position, h.value = {
        x: (u.value.p1.x + u.value.p2.x) / 2,
        y: (u.value.p1.y + u.value.p2.y) / 2
      });
    });
    const l = O(() => Object.keys(t.edges)), p = O(() => _.values(n.summarized.label, t.edges)), w = O(() => _.values(n.summarized.shape, t.edges)), k = O(() => _.values(n.summarized.stroke, t.edges)), y = O(() => l.value.some((E) => d[E].hovered)), v = O(() => l.value.some((E) => d[E].selectable)), b = O(() => l.value.some((E) => d[E].selected));
    return (E, g) => (S(), I("g", {
      class: he({ "v-ng-line-summarized": !0, hovered: y.value, selectable: v.value, selected: b.value }),
      onPointerdown: g[0] || (g[0] = we((f) => M(o)(l.value, f), ["stop"])),
      onPointerenterPassive: g[1] || (g[1] = (f) => M(i)(l.value, f)),
      onPointerleavePassive: g[2] || (g[2] = (f) => M(s)(l.value, f)),
      onClick: g[3] || (g[3] = we((f) => M(r)(l.value, f), ["stop"])),
      onDblclick: g[4] || (g[4] = we((f) => M(a)(l.value, f), ["stop"])),
      onContextmenu: g[5] || (g[5] = (f) => M(c)(l.value, f))
    }, [
      je(uo, oe(u.value, {
        config: k.value,
        "data-edge-id": l.value[0]
      }), null, 16, ["config", "data-edge-id"]),
      je(wt, {
        "base-x": h.value.x,
        "base-y": h.value.y,
        config: w.value
      }, null, 8, ["base-x", "base-y", "config"]),
      je(Et, {
        text: Object.keys(E.edges).length.toString(),
        x: h.value.x,
        y: h.value.y,
        config: p.value,
        "text-anchor": "middle",
        "dominant-baseline": "central"
      }, null, 8, ["text", "x", "y", "config"])
    ], 34));
  }
}), mr = { class: "v-ng-edge-overlay" }, Mn = /* @__PURE__ */ F({
  __name: "VEdgeOverlay",
  props: {
    edgeId: { default: void 0 },
    edge: { default: void 0 },
    edges: { default: () => ({}) },
    state: {},
    isSummarized: { type: Boolean }
  },
  setup(e) {
    const t = e, { svg: n } = Vt(), { scale: o } = ge(), i = mt();
    function s() {
      return t.isSummarized ? _.values(i.summarized.stroke, t.edges) : t.state.line.stroke;
    }
    function r(u) {
      return { source: u.p1, target: u.p2 };
    }
    function a(u) {
      if (u.curve)
        return u.curve.center;
      {
        const h = u.origin.p1, l = u.origin.p2;
        return {
          x: (h.x + l.x) / 2,
          y: (h.y + l.y) / 2
        };
      }
    }
    function c() {
      var l;
      if (!n.value) return 0;
      const u = (l = t.edgeId) != null ? l : Object.keys(t.edges)[0], h = n.value.querySelector(`path[data-edge-id="${u}"]`);
      return h ? h.getTotalLength() : 0;
    }
    function d(u) {
      var w;
      if (!n.value || !isFinite(u)) return t.state.position.p1;
      t.state;
      const h = (w = t.edgeId) != null ? w : Object.keys(t.edges)[0], l = n.value.querySelector(`path[data-edge-id="${h}"]`);
      if (!l) return t.state.position.p1;
      const p = l.getPointAtLength(u);
      return { x: p.x, y: p.y };
    }
    return (u, h) => (S(), I("g", mr, [
      u.isSummarized ? Y(u.$slots, "default", {
        key: 0,
        edges: u.edges,
        isSummarized: u.isSummarized,
        stroke: s(),
        position: r(u.state.origin),
        center: a(u.state),
        hovered: u.state.hovered,
        selected: u.state.selected,
        scale: M(o),
        length: c(),
        pointAtLength: d
      }) : Y(u.$slots, "default", {
        key: 1,
        edgeId: u.edgeId,
        edge: u.edge,
        edges: { [u.edgeId]: u.edge },
        isSummarized: u.isSummarized,
        stroke: s(),
        position: r(u.state.origin),
        center: a(u.state),
        hovered: u.state.hovered,
        selected: u.state.selected,
        scale: M(o),
        length: c(),
        pointAtLength: d
      })
    ]));
  }
}), br = /* @__PURE__ */ F({
  __name: "VEdgeGroups",
  props: {
    hasEdgeOverlaySlot: { type: Boolean }
  },
  setup(e) {
    const { edgeStates: t, edgeZOrderedList: n, layouts: o } = ke();
    return (i, s) => (S(!0), I(G, null, J(M(n), (r) => (S(), I(G, null, [
      M(zi)(r) ? (S(), I(G, { key: 0 }, [
        (S(), W(gr, {
          key: r.key,
          edges: r.group.edges,
          layouts: M(o).nodes
        }, null, 8, ["edges", "layouts"])),
        i.hasEdgeOverlaySlot ? (S(), W(Mn, {
          key: r.key,
          edges: r.group.edges,
          state: M(t)[Object.keys(r.group.edges)[0]],
          "is-summarized": !0
        }, {
          default: ne((a) => [
            Y(i.$slots, "default", oe({ ref_for: !0 }, a))
          ]),
          _: 2
        }, 1032, ["edges", "state"])) : ue("", !0)
      ], 64)) : (S(), I(G, { key: 1 }, [
        (S(), W(ur, {
          id: r.key,
          key: r.key,
          state: M(t)[r.key],
          "source-pos": M(o).nodes[r.edge.source],
          "target-pos": M(o).nodes[r.edge.target]
        }, null, 8, ["id", "state", "source-pos", "target-pos"])),
        i.hasEdgeOverlaySlot ? (S(), W(Mn, {
          key: r.key,
          "edge-id": r.key,
          edge: r.edge,
          state: M(t)[r.key],
          "is-summarized": !1
        }, {
          default: ne((a) => [
            Y(i.$slots, "default", oe({ ref_for: !0 }, a))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"])) : ue("", !0)
      ], 64))
    ], 64))), 256));
  }
}), yr = { class: "v-ng-layer-edges v-ng-graph-objects" }, wr = /* @__PURE__ */ F({
  __name: "VEdgesLayer",
  setup(e) {
    const t = ht(), n = O(() => "edge-overlay" in t);
    return (o, i) => (S(), I("g", yr, [
      je(ir),
      je(br, { "has-edge-overlay-slot": n.value }, Bt({ _: 2 }, [
        n.value ? {
          name: "default",
          fn: ne((s) => [
            Y(o.$slots, "edge-overlay", _t(It(s)))
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["has-edge-overlay-slot"])
    ]));
  }
}), Er = /* @__PURE__ */ F({
  __name: "VEdgeLabelPlace",
  props: {
    edgeId: {},
    edge: {},
    state: {}
  },
  setup(e) {
    const t = e, { scale: n } = ge(), o = O(() => Hn(
      t.state.labelPosition,
      t.state.line.stroke,
      t.state.label.margin,
      t.state.label.padding,
      n.value
    ));
    return (i, s) => i.state.loop ? ue("", !0) : Y(i.$slots, "default", {
      key: 0,
      edgeId: i.edgeId,
      edge: i.edge,
      config: i.state.label,
      area: o.value,
      hovered: i.state.hovered,
      selected: i.state.selected,
      scale: M(n)
    });
  }
}), kr = /* @__PURE__ */ F({
  __name: "VEdgeLabelsPlace",
  props: {
    edges: {},
    state: {},
    summarizeState: {}
  },
  setup(e) {
    const t = e, { scale: n } = ge(), o = O(() => {
      var i, s;
      return Hn(
        t.state.labelPosition,
        (s = (i = t.summarizeState) == null ? void 0 : i.stroke) != null ? s : t.state.line.stroke,
        t.state.label.margin,
        t.state.label.padding,
        n.value
      );
    });
    return (i, s) => i.state.loop ? ue("", !0) : Y(i.$slots, "default", {
      key: 0,
      edges: i.edges,
      config: i.state.label,
      area: o.value,
      hovered: i.state.hovered,
      selected: i.state.selected,
      scale: M(n)
    });
  }
}), xr = { class: "v-ng-edge-labels" }, Pr = /* @__PURE__ */ F({
  __name: "VEdgeLabels",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    const { edgeStates: t, edgeGroupStates: n, summarizedEdgeStates: o } = ke(), i = O(() => {
      const r = {}, a = {};
      return Object.entries(n.edgeGroups).forEach(([c, d]) => {
        Object.keys(d.edges).length > 0 && (d.summarize ? a[c] = d : r[c] = d);
      }), { individual: r, summarized: a };
    });
    function s(r) {
      return Object.keys(r.edges)[0];
    }
    return (r, a) => (S(), I("g", xr, [
      r.enableEdgeLabel ? (S(!0), I(G, { key: 0 }, J(i.value.individual, (c, d) => (S(), I(G, { key: d }, [
        (S(!0), I(G, null, J(c.edges, (u, h) => (S(), W(Er, {
          key: h,
          "edge-id": h,
          edge: u,
          state: M(t)[h]
        }, {
          default: ne((l) => [
            Y(r.$slots, "edge-label", oe({ ref_for: !0 }, l))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"]))), 128))
      ], 64))), 128)) : ue("", !0),
      r.enableEdgesLabel ? (S(!0), I(G, { key: 1 }, J(i.value.summarized, (c, d) => (S(), W(kr, {
        key: d,
        edges: c.edges,
        state: M(t)[s(c)],
        "summarize-state": M(o)[s(c)]
      }, {
        default: ne((u) => [
          Y(r.$slots, "edges-label", oe({ ref_for: !0 }, u))
        ]),
        _: 2
      }, 1032, ["edges", "state", "summarize-state"]))), 128)) : ue("", !0)
    ]));
  }
}), Sr = /* @__PURE__ */ F({
  __name: "VEdgeLabelsLayer",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (S(), W(Pr, {
      "enable-edge-label": t.enableEdgeLabel,
      "enable-edges-label": t.enableEdgesLabel,
      class: "v-ng-layer-edge-labels v-ng-graph-objects"
    }, Bt({ _: 2 }, [
      t.enableEdgeLabel ? {
        name: "edge-label",
        fn: ne((o) => [
          Y(t.$slots, "edge-label", _t(It(o)))
        ]),
        key: "0"
      } : void 0,
      t.enableEdgesLabel ? {
        name: "edges-label",
        fn: ne((o) => [
          Y(t.$slots, "edges-label", _t(It(o)))
        ]),
        key: "1"
      } : void 0
    ]), 1032, ["enable-edge-label", "enable-edges-label"]));
  }
}), Mr = /* @__PURE__ */ F({
  __name: "VNodeFocusRing",
  props: {
    id: {},
    state: {},
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = O(() => {
      var r;
      return ((r = t.pos) == null ? void 0 : r.x) || 0;
    }), o = O(() => {
      var r;
      return ((r = t.pos) == null ? void 0 : r.y) || 0;
    }), i = gt(), s = Me({});
    return ve(() => {
      var a, c, d;
      const r = t.state.shape;
      if (r.type === "circle") {
        const u = {
          type: "circle",
          radius: r.radius + ((a = r.strokeWidth) != null ? a : 0) / 2 + i.focusring.padding + i.focusring.width / 2,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, u);
      } else {
        const u = {
          type: "rect",
          width: r.width + ((c = r.strokeWidth) != null ? c : 0) + i.focusring.padding * 2 + i.focusring.width,
          height: r.height + ((d = r.strokeWidth) != null ? d : 0) + i.focusring.padding * 2 + i.focusring.width,
          borderRadius: r.borderRadius > 0 ? r.borderRadius + i.focusring.padding : 0,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, u);
      }
    }), (r, a) => (S(), W(wt, {
      class: "v-ng-node-focusring",
      "base-x": n.value,
      "base-y": o.value,
      config: s
    }, null, 8, ["base-x", "base-y", "config"]));
  }
}), Cr = { class: "v-ng-layer-nodes-selections" }, Or = /* @__PURE__ */ F({
  __name: "VFocusringLayer",
  setup(e) {
    const { nodeStates: t } = ke(), { selectedNodes: n } = xs(), o = en();
    return (i, s) => (S(), I("g", Cr, [
      (S(!0), I(G, null, J(M(n), (r) => (S(), W(Mr, {
        id: r,
        key: r,
        state: M(t)[r],
        pos: M(o).nodes[r]
      }, null, 8, ["id", "state", "pos"]))), 128))
    ]));
  }
}), zr = ["transform"], Cn = /* @__PURE__ */ F({
  __name: "VNode",
  props: {
    id: {},
    state: {},
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = O(() => {
      var h;
      return ((h = t.pos) == null ? void 0 : h.x) || 0;
    }), o = O(() => {
      var h;
      return ((h = t.pos) == null ? void 0 : h.y) || 0;
    }), { scale: i } = ge(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: r,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: c,
      handleNodeDoubleClickEvent: d,
      handleNodeContextMenu: u
    } = ot();
    return (h, l) => (S(), I("g", {
      class: he({ "v-ng-node": !0, hover: h.state.hovered, selected: h.state.selected }),
      transform: `translate(${n.value} ${o.value})`,
      onPointerdown: l[0] || (l[0] = we((p) => M(s)(h.id, p), ["stop"])),
      onPointerenterPassive: l[1] || (l[1] = (p) => M(r)(h.id, p)),
      onPointerleavePassive: l[2] || (l[2] = (p) => M(a)(h.id, p)),
      onClick: l[3] || (l[3] = we((p) => M(c)(h.id, p), ["stop"])),
      onDblclick: l[4] || (l[4] = we((p) => M(d)(h.id, p), ["stop"])),
      onContextmenu: l[5] || (l[5] = (p) => M(u)(h.id, p))
    }, [
      Y(h.$slots, "override-node", {
        nodeId: h.id,
        scale: M(i),
        config: h.state.shape,
        class: he({ draggable: h.state.draggable, selectable: h.state.selectable })
      }, () => [
        je(wt, {
          config: h.state.shape,
          class: he({
            "v-ng-node-default": !0,
            draggable: h.state.draggable,
            selectable: h.state.selectable
          })
        }, null, 8, ["config", "class"])
      ])
    ], 42, zr));
  }
}), Tr = /* @__PURE__ */ F({
  __name: "VNodesLayer",
  setup(e) {
    const t = ht(), n = O(() => "override-node" in t), { nodeZOrderedList: o } = ke(), i = gt(), s = en();
    return (r, a) => n.value ? (S(), W(Qe, {
      key: 0,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes v-ng-graph-objects"
    }, {
      default: ne(() => [
        (S(!0), I(G, null, J(M(o), (c) => (S(), W(Cn, {
          id: c.id,
          key: c.id,
          state: c,
          pos: M(s).nodes[c.id]
        }, {
          "override-node": ne((d) => [
            Y(r.$slots, "override-node", oe({ ref_for: !0 }, d))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (S(), W(Qe, {
      key: 1,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes v-ng-graph-objects"
    }, {
      default: ne(() => [
        (S(!0), I(G, null, J(M(o), (c) => (S(), W(Cn, {
          id: c.id,
          key: c.id,
          state: c,
          pos: M(s).nodes[c.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), fo = {
  [D.NORTH]: 0,
  [D.NORTH_EAST]: 1,
  [D.EAST]: 2,
  [D.SOUTH_EAST]: 3,
  [D.SOUTH]: 4,
  [D.SOUTH_WEST]: 5,
  [D.WEST]: 6,
  [D.NORTH_WEST]: 7,
  [D.CENTER]: -1
}, _r = [
  /* N */
  (e, t) => Ce(e, 0, t ? 90 : 60),
  /* NE */
  (e, t) => Ce(e, 45, t ? 90 : 45),
  /* E */
  (e, t) => Ce(e, 90, t ? 60 : 30),
  /* SE */
  (e, t) => Ce(e, 135, t ? 90 : 45),
  /* S */
  (e, t) => Ce(e, 180, t ? 90 : 60),
  /* SW */
  (e, t) => Ce(e, 225, t ? 90 : 45),
  /* W */
  (e, t) => Ce(e, 270, t ? 60 : 30),
  /* NW */
  (e, t) => Ce(e, 315, t ? 90 : 45)
];
function Ir(e, t, n, o, i) {
  if (i === D.CENTER)
    return D.CENTER;
  const s = [];
  Object.entries(n).forEach(([d, u]) => {
    let h = !1;
    if (u.nodeId === e) {
      const p = o(d);
      p && (h = !0, u = Xe(se({}, u), {
        pos: { x: p.x, y: p.y }
      }));
    }
    const l = (Gt(Wt(u.pos, t)) + 360 + 90) % 360;
    s.push([l, h]);
  });
  const r = $r(i), c = [
    r,
    (r + 4) % 8,
    // priority is given to diagonals
    (r + 2) % 8,
    (r - 2 + 8) % 8,
    (r + 1) % 8,
    (r - 1 + 8) % 8,
    (r + 3) % 8,
    (r - 3 + 8) % 8
  ].find((d) => s.every((u) => !_r[d](...u)));
  return c === void 0 ? i : Lr(c, i);
}
function Ce(e, t, n) {
  e %= 360;
  const o = (t - n + 360) % 360, i = (t + n) % 360;
  return o <= i ? o < e && e < i : o < e || e < i;
}
function $r(e) {
  var t;
  return (t = fo[e]) != null ? t : 0;
}
function Lr(e, t) {
  var n, o;
  return (o = (n = Object.entries(fo)[e]) == null ? void 0 : n[0]) != null ? o : t;
}
const Ar = ["transform"], On = /* @__PURE__ */ F({
  __name: "VNodeLabel",
  props: {
    id: {},
    state: {},
    pos: { default: void 0 }
  },
  setup(e) {
    const t = e, n = gt(), { edgeStates: o } = ke(), { scale: i } = ge(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: r,
      handleNodePointerOutEvent: a,
      handleNodeClickEvent: c,
      handleNodeDoubleClickEvent: d,
      handleNodeContextMenu: u
    } = ot(), h = O(() => {
      var C;
      return ((C = t.pos) == null ? void 0 : C.x) || 0;
    }), l = O(() => {
      var C;
      return ((C = t.pos) == null ? void 0 : C.y) || 0;
    }), p = O(() => t.state.label.direction === D.CENTER ? 0 : t.state.label.margin * i.value), w = j(0), k = j(0), y = j(0), v = j(0), b = O(() => {
      var N;
      const C = t.state.label.direction, T = t.state.label.directionAutoAdjustment;
      if (T === !1)
        return C;
      const L = { x: h.value, y: l.value };
      return T === !0 ? Ir(
        t.state.id,
        L,
        t.state.oppositeNodes,
        (K) => {
          var B, H;
          return (H = (B = o[K]) == null ? void 0 : B.loop) == null ? void 0 : H.center;
        },
        C
      ) : (N = T({
        nodeId: t.state.id,
        pos: L,
        oppositeNodes: t.state.oppositeNodes
      })) != null ? N : C;
    }), E = O(() => {
      switch (b.value) {
        case D.CENTER:
        case D.NORTH:
        case D.SOUTH:
          return "middle";
        case D.EAST:
        case D.NORTH_EAST:
        case D.SOUTH_EAST:
          return "start";
        case D.WEST:
        case D.NORTH_WEST:
        case D.SOUTH_WEST:
        default:
          return "end";
      }
    }), g = O(() => {
      switch (b.value) {
        case D.NORTH:
        case D.NORTH_EAST:
        case D.NORTH_WEST:
          return "text-top";
        case D.SOUTH:
        case D.SOUTH_EAST:
        case D.SOUTH_WEST:
          return "hanging";
        case D.CENTER:
        case D.EAST:
        case D.WEST:
        default:
          return "central";
      }
    }), f = O(() => {
      switch (b.value) {
        case D.CENTER:
        case D.NORTH:
        case D.SOUTH:
          return 0;
        case D.EAST:
          return k.value;
        case D.WEST:
          return -k.value;
        case D.NORTH_EAST:
        case D.SOUTH_EAST:
          return v.value;
        case D.NORTH_WEST:
        case D.SOUTH_WEST:
        default:
          return -v.value;
      }
    }), m = O(() => {
      switch (b.value) {
        case D.NORTH:
          return -w.value;
        case D.SOUTH:
          return w.value;
        case D.CENTER:
        case D.EAST:
        case D.WEST:
          return 0;
        case D.NORTH_EAST:
        case D.NORTH_WEST:
          return -y.value;
        case D.SOUTH_EAST:
        case D.SOUTH_WEST:
        default:
          return y.value;
      }
    });
    ve(() => {
      const C = i.value, T = t.state.shape;
      if (T.type == "circle") {
        const L = T.radius * C, N = L + p.value, K = Math.sqrt(ae(N, 2) / 2);
        w.value = L + p.value, k.value = L + p.value, y.value = K, v.value = K;
      } else {
        const L = T.borderRadius * C, N = T.width * C, K = T.height * C, B = L + p.value, H = Math.sqrt(ae(B, 2) / 2);
        w.value = K / 2 + p.value, k.value = N / 2 + p.value, y.value = K / 2 - L + H, v.value = N / 2 - L + H;
      }
    });
    const x = O(() => (C) => n.label.handleNodeEvents ? {
      pointerdown: (T) => {
        T.stopPropagation(), s(C, T);
      },
      pointerenter: (T) => r(C, T),
      pointerleave: (T) => a(C, T),
      click: (T) => {
        T.stopPropagation(), c(C, T);
      },
      dblclick: (T) => {
        T.stopPropagation(), d(C, T);
      },
      contextmenu: (T) => {
        u(C, T);
      }
    } : {}), z = O(() => {
      const C = n.label.handleNodeEvents;
      return {
        "v-ng-node-label": !0,
        hover: C && t.state.hovered,
        selected: C && t.state.selected
      };
    }), $ = O(() => {
      const C = n.label.handleNodeEvents;
      return {
        draggable: C && t.state.draggable,
        selectable: C && t.state.selectable
      };
    });
    return (C, T) => (S(), I("g", oe({
      class: z.value,
      transform: `translate(${h.value} ${l.value})`
    }, Vo(x.value(C.id), !0)), [
      Y(C.$slots, "override-node-label", {
        nodeId: C.id,
        scale: M(i),
        text: C.state.labelText,
        x: f.value,
        y: m.value,
        config: C.state.label,
        shape: C.state.shape,
        textAnchor: E.value,
        dominantBaseline: g.value,
        class: he($.value)
      }, () => [
        je(Et, {
          text: C.state.labelText,
          x: 0,
          y: 0,
          config: C.state.label,
          "text-anchor": E.value,
          "dominant-baseline": g.value,
          class: he($.value),
          transform: `translate(${f.value} ${m.value})`
        }, null, 8, ["text", "config", "text-anchor", "dominant-baseline", "class", "transform"])
      ])
    ], 16, Ar));
  }
}), Zr = /* @__PURE__ */ F({
  __name: "VNodeLabelsLayer",
  setup(e) {
    const t = ht(), n = O(() => "override-node-label" in t), { nodeZOrderedList: o } = ke(), i = gt(), s = en(), r = O(() => a(o.value));
    function a(c) {
      return c.filter((d) => {
        var u;
        return d.label.visible && ((u = d.labelText) != null ? u : !1);
      });
    }
    return (c, d) => n.value ? (S(), W(Qe, {
      key: 0,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels v-ng-graph-objects"
    }, {
      default: ne(() => [
        (S(!0), I(G, null, J(r.value, (u) => (S(), W(On, {
          id: u.id,
          key: u.id,
          state: u,
          pos: M(s).nodes[u.id]
        }, {
          "override-node-label": ne((h) => [
            Y(c.$slots, "override-node-label", oe({ ref_for: !0 }, h))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (S(), W(Qe, {
      key: 1,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels v-ng-graph-objects"
    }, {
      default: ne(() => [
        (S(!0), I(G, null, J(r.value, (u) => (S(), W(On, {
          id: u.id,
          key: u.id,
          state: u,
          pos: M(s).nodes[u.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), Dr = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"], Nr = /* @__PURE__ */ F({
  __name: "VPath",
  props: {
    path: {}
  },
  setup(e) {
    const t = e, { nodeStates: n, edgeStates: o, layouts: i } = ke(), { scale: s } = ge(), r = Zn();
    function a(l) {
      if (l.edges.length === 0) return [];
      const p = _.value(r.margin, l.path) * s.value;
      return mi(
        l,
        n,
        i.nodes,
        o,
        s.value,
        r.curveInNode,
        r.end,
        p
      );
    }
    function c(l) {
      const p = a(l);
      let w = !0;
      return p.map((k) => {
        if (k === null)
          w = !0;
        else {
          if (typeof k == "string")
            return k;
          if (k instanceof Array) {
            k = [...k];
            const y = [];
            if (k.length % 2 === 1) {
              const v = k[0];
              k = k.slice(1), y.push(`L ${v.x} ${v.y}`);
            }
            return Rt(k, 2).map(([v, b]) => y.push(`Q ${v.x} ${v.y} ${b.x} ${b.y}`)), y.join(" ");
          } else {
            const y = w;
            return w = !1, `${y ? "M " : "L "}${k.x} ${k.y}`;
          }
        }
      }).join(" ");
    }
    const d = O(() => {
      const l = t.path;
      return l.selected ? _.values(r.selected, l.path) : l.hovered && r.hover ? _.values(r.hover, l.path) : _.values(r.normal, l.path);
    }), u = O(() => nt(d.value.dasharray, s.value)), h = O(() => {
      const l = d.value.animate ? pt(d.value.dasharray) * d.value.animationSpeed * s.value : !1;
      return l ? { "--animation-speed": l } : void 0;
    });
    return (l, p) => (S(), I("path", {
      class: he({
        "v-ng-path": !0,
        animate: d.value.animate,
        clickable: l.path.clickable,
        hoverable: l.path.hoverable
      }),
      d: c(l.path),
      fill: "none",
      stroke: d.value.color,
      "stroke-width": d.value.width * M(s),
      "stroke-dasharray": u.value,
      "stroke-linecap": d.value.linecap,
      "stroke-linejoin": d.value.linejoin,
      style: tt(h.value)
    }, null, 14, Dr));
  }
}), jr = /* @__PURE__ */ F({
  __name: "VPaths",
  setup(e) {
    const { pathZOrderedList: t } = ke(), n = Zn(), {
      handlePathPointerDownEvent: o,
      handlePathPointerOverEvent: i,
      handlePathPointerOutEvent: s,
      handlePathClickEvent: r,
      handlePathDoubleClickEvent: a,
      handlePathContextMenu: c
    } = ot();
    return (d, u) => (S(), W(Qe, {
      name: M(n).transition,
      css: !!M(n).transition,
      tag: "g",
      class: "v-ng-paths v-ng-layer-paths v-ng-graph-objects"
    }, {
      default: ne(() => [
        (S(!0), I(G, null, J(M(t), (h) => (S(), W(Nr, {
          key: h.id,
          path: h,
          onPointerdown: (l) => M(o)(h.id, l),
          onPointerenterPassive: (l) => M(i)(h.id, l),
          onPointerleavePassive: (l) => M(s)(h.id, l),
          onClick: we((l) => M(r)(h.id, l), ["stop"]),
          onDblclick: we((l) => M(a)(h.id, l), ["stop"]),
          onContextmenu: (l) => M(c)(h.id, l)
        }, null, 8, ["path", "onPointerdown", "onPointerenterPassive", "onPointerleavePassive", "onClick", "onDblclick", "onContextmenu"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), Br = /* @__PURE__ */ F({
  __name: "VPathsLayer",
  setup(e) {
    return (t, n) => (S(), W(jr));
  }
}), Rr = { key: 0 }, Vr = /* @__PURE__ */ F({
  __name: "VNetworkGraph",
  props: {
    nodes: { default: () => ({}) },
    edges: { default: () => ({}) },
    paths: { default: () => ({}) },
    layouts: { default: () => ({}) },
    zoomLevel: { default: 1 },
    selectedNodes: { default: () => [] },
    selectedEdges: { default: () => [] },
    selectedPaths: { default: () => [] },
    configs: { default: () => ({}) },
    layers: { default: () => ({}) },
    eventHandlers: { default: () => ({}) }
  },
  emits: ["update:zoomLevel", "update:selectedNodes", "update:selectedEdges", "update:selectedPaths", "update:layouts"],
  setup(e, { expose: t, emit: n }) {
    const o = [
      "override-node",
      "override-node-label",
      "edge-overlay",
      "edge-label",
      "edges-label"
    ], i = e, s = n, r = ht(), a = Se(i, "nodes"), c = Se(i, "edges"), { objects: d, isInCompatibilityModeForPath: u } = ws(
      Se(i, "paths")
    ), h = es();
    Object.entries(i.eventHandlers).forEach(([P, Z]) => {
      h.on(P, Z);
    });
    const l = Yo(Se(i, "configs")), p = O(() => {
      const P = new Set(Object.keys(r));
      o.forEach((A) => P.delete(A));
      const Z = Object.fromEntries(Xo.map((A) => [A, []]));
      return Object.assign(
        Z,
        Object.entries(i.layers).reduce(
          (A, [V, te]) => (P.delete(V), te in A ? A[te].push(V) : A[te] = [V], A),
          {}
        )
      ), Z.root.push(...P), Z;
    }), w = O(() => l.view.grid.visible), k = O(() => {
      const P = p.value;
      return w.value || P.background.length > 0 || P.grid.length > 0;
    }), y = Cs(l, r), v = j(), b = j(), E = j(), g = j(
      0
      /* INITIAL */
    ), f = O(
      () => g.value !== 0
      /* INITIAL */
    ), m = Es(i, "zoomLevel", s, (P) => (P = Math.max(P, l.view.minZoomLevel), P = Math.min(P, l.view.maxZoomLevel), P)), { svgPanZoom: x, onSvgPanZoomMounted: z, onSvgPanZoomUnmounted: $ } = gs(b, {
      viewportSelector: ".v-ng-viewport",
      minZoom: l.view.minZoomLevel,
      // temporary
      maxZoom: l.view.maxZoomLevel,
      // temporary
      dblClickZoomEnabled: rn(l.view),
      mouseWheelZoomEnabled: Pt(l.view),
      fit: l.view.autoPanAndZoomOnLoad === "fit-content",
      center: l.view.autoPanAndZoomOnLoad !== !1,
      zoomEnabled: l.view.zoomEnabled,
      preventMouseEventsDefault: !1,
      onZoom: (P) => {
        var A, V;
        if (g.value === 2) return;
        const Z = (V = (A = x.value) == null ? void 0 : A.getRealZoom()) != null ? V : 1;
        Math.abs(m.value - Z) >= 1e-6 && (m.value = Z, h.emit("view:zoom", Z));
      },
      panEnabled: l.view.panEnabled,
      onPan: (P) => {
        g.value !== 2 && h.emit("view:pan", P);
      }
    });
    qo({ container: v, svg: b, viewport: E, svgPanZoom: x });
    const C = { width: 0, height: 0 }, T = globalThis.ResizeObserver ? new ResizeObserver(() => {
      var Z, A, V;
      if ((Z = x.value) == null || Z.resize(), !l.view.autoPanOnResize) return;
      const P = (A = v.value) == null ? void 0 : A.getBoundingClientRect();
      if (P) {
        const te = -(C.width - P.width) / 2, De = -(C.height - P.height) / 2;
        (V = x.value) == null || V.panBy({ x: te, y: De });
        const { width: Pe, height: St } = P;
        (C.width !== Pe || C.height !== St) && (Object.assign(C, { width: Pe, height: St }), h.emit("view:resize", { x: P.x, y: P.y, width: Pe, height: St }));
      }
    }) : void 0;
    z(() => {
      var te, De, Pe;
      const P = q(v.value, "svg-pan-zoom container");
      T == null || T.observe(P), (De = (te = l.view).onSvgPanZoomInitialized) == null || De.call(te, q(x.value, "svg-pan-zoom instance"));
      const Z = P.getBoundingClientRect(), { width: A, height: V } = Z;
      Object.assign(C, { width: A, height: V }), (Pe = E.value) == null || Pe.addEventListener("touchstart", an, { passive: !1 });
    }), $(() => {
      var P;
      T == null || T.disconnect(), (P = E.value) == null || P.removeEventListener("touchstart", an);
    });
    const L = (P) => {
      var Z;
      (Z = x.value) == null || Z.applyAbsoluteZoomLevel(
        P,
        l.view.minZoomLevel,
        l.view.maxZoomLevel
      );
    };
    U(
      () => l.view.panEnabled,
      (P) => {
        var Z;
        (Z = x.value) == null || Z.setPanEnabled(P);
      }
    ), U(
      () => [
        l.view.zoomEnabled,
        rn(l.view),
        Pt(l.view)
      ],
      () => {
        const P = x.value;
        P && $o(
          P,
          l.view.zoomEnabled,
          l.view.doubleClickZoomEnabled,
          l.view.mouseWheelZoomEnabled
        );
      }
    ), U(m, (P) => L(P)), U(
      () => [l.view.minZoomLevel, l.view.maxZoomLevel],
      (P) => {
        L(m.value);
      }
    );
    const { scale: N } = ms(m, l.view);
    z(() => {
      const P = i.zoomLevel;
      L(P);
    });
    const K = () => ye(this, null, function* () {
      var P;
      Object.keys(i.nodes).length > 0 && ((P = x.value) == null || P.updateBBox(), yield Sn());
    }), B = (P) => ye(this, null, function* () {
      var De, Pe;
      const Z = !P || P.margin === void 0 ? l.view.fitContentMargin : P.margin;
      yield K();
      const A = q(b.value).getBoundingClientRect(), V = Ls(Z, A), te = As(
        q(E.value),
        A,
        xe.nodes,
        m.value,
        V,
        l.view.scalingObjects
      );
      te ? (L(te.zoom), (De = x.value) == null || De.pan(te.pos)) : (Pe = x.value) == null || Pe.center(), h.emit("view:fit", void 0);
    }), H = () => ye(this, null, function* () {
      var P;
      yield K(), (P = x.value) == null || P.center();
    }), me = () => {
      var P, Z;
      return (Z = (P = x.value) == null ? void 0 : P.getViewBox()) != null ? Z : {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }, le = (P) => {
      var Z;
      return (Z = x.value) == null ? void 0 : Z.setViewBox(P);
    }, Ee = Tt(i, "selectedNodes", a, s);
    U(Ee, (P) => h.emit("node:select", Array.from(P)));
    const Ae = Tt(i, "selectedEdges", c, s);
    U(Ae, (P) => h.emit("edge:select", Array.from(P)));
    const Ze = Tt(i, "selectedPaths", d, s);
    U(Ze, (P) => h.emit("path:select", Array.from(P))), ks(Ee, Ae, Ze);
    const ce = ze(/* @__PURE__ */ new Set()), Be = ze(/* @__PURE__ */ new Set()), Re = ze(/* @__PURE__ */ new Set()), xe = ze({ nodes: {} });
    Ps(xe), U(
      () => i.layouts,
      () => {
        var P;
        return Object.assign(xe.nodes, (P = i.layouts.nodes) != null ? P : {});
      },
      { deep: !0, immediate: !0 }
    ), U(xe, () => s("update:layouts", xe), { deep: !0 });
    const kt = xi(), xt = j(!1);
    h.on("node:dragstart", (P) => xt.value = !0), h.on("node:dragend", (P) => xt.value = !1), h.on("view:mode", (P) => {
      var Z, A, V, te;
      l.view.panEnabled && (P === "default" ? (Z = x.value) == null || Z.enablePan() : (A = x.value) == null || A.disablePan()), l.view.zoomEnabled && (P === "default" ? (V = x.value) == null || V.enableZoom() : (te = x.value) == null || te.disableZoom());
    });
    const ho = O(() => l.view.panEnabled || l.view.zoomEnabled || l.node.draggable), { nodeStates: po, edgeStates: vo, pathStates: go } = Oi(
      Ot(a, Ee, ce),
      Ot(c, Ae, Be),
      Ot(d, Ze, Re),
      qe(l),
      xe,
      i.layouts,
      kt,
      N
    ), mo = O(() => Pt(l.view)), { isBoxSelectionMode: bo, selectionBox: tn, startBoxSelection: yo, stopBoxSelection: wo } = Qi(
      b,
      qe(xe),
      qe(m),
      po,
      vo,
      go,
      Ee,
      Ae,
      Ze,
      ce,
      Be,
      Re,
      u,
      mo,
      l,
      h
    ), nn = () => ({
      layouts: ze(xe.nodes),
      // deprecated parameter.
      nodePositions: Se(xe, "nodes"),
      nodes: a,
      edges: c,
      configs: qe(l),
      scale: qe(N),
      emitter: h,
      svgPanZoom: q(x.value)
    });
    U(
      () => l.view.layoutHandler,
      (P, Z) => {
        Z.deactivate(), P.activate(nn());
      }
    );
    const { transitionWhile: Eo, transitionOption: on } = ys(), ko = O(() => {
      const P = on.value;
      return P.enabled ? {
        "--transition-duration": P.duration + "ms",
        "--transition-function": P.timingFunction
      } : {};
    });
    z(() => ye(this, null, function* () {
      if (l.view.onBeforeInitialDisplay) {
        const A = l.view.onBeforeInitialDisplay();
        ti(A) && (yield A);
      }
      const P = q(x.value, "svg-pan-zoom");
      l.view.layoutHandler.activate(nn()), yield Sn();
      const Z = l.view.autoPanAndZoomOnLoad;
      if (l.view.fit || Z !== !1) {
        const A = Object.keys(i.nodes).length == 0, V = P.getPan();
        if (A || Z === "center-zero") {
          yield K();
          const te = P.getSizes();
          P.pan({
            x: te.width / 2,
            y: te.height / 2
          });
        } else Z === "fit-content" || l.view.fit ? yield B() : Z === "center-content" ? yield H() : yield K();
        jt(() => {
          const te = P.getPan();
          V.x === te.x && V.y === te.y && h.emit("view:pan", te);
        });
      } else
        yield K();
      h.emit("view:load"), g.value = 1;
    })), $(() => {
      g.value = 2, h.emit("view:unload"), l.view.layoutHandler.deactivate();
    });
    function xo() {
      var P;
      (P = x.value) == null || P.zoomIn();
    }
    function Po() {
      var P;
      (P = x.value) == null || P.zoomOut();
    }
    function So(P) {
      var Z;
      (Z = x.value) == null || Z.pan(P);
    }
    function Mo(P) {
      var Z;
      (Z = x.value) == null || Z.panBy(P);
    }
    function Co() {
      return q(x.value).getPan();
    }
    function Oo() {
      const P = q(x.value).getSizes();
      return {
        width: P.width,
        height: P.height,
        viewBox: P.viewBox
      };
    }
    function zo(P) {
      return Dt(
        q(b.value, "svg"),
        q(E.value, "viewport"),
        P
      );
    }
    function To(P) {
      return Fi(
        q(b.value, "svg"),
        q(E.value, "viewport"),
        P
      );
    }
    function _o() {
      return Kn(
        q(b.value, "svg"),
        q(E.value, "viewport"),
        N.value
      ).outerHTML;
    }
    function Io() {
      return ye(this, arguments, function* (P = {}) {
        return (yield sn(P)).outerHTML;
      });
    }
    function sn() {
      return ye(this, arguments, function* (P = {}) {
        return Xi(
          q(b.value, "svg"),
          q(E.value, "viewport"),
          N.value,
          P
        );
      });
    }
    t({
      // methods
      fitToContents: B,
      panToCenter: H,
      getViewBox: me,
      setViewBox: le,
      transitionWhile: Eo,
      startBoxSelection: yo,
      stopBoxSelection: wo,
      zoomIn: xo,
      zoomOut: Po,
      panTo: So,
      panBy: Mo,
      getPan: Co,
      getSizes: Oo,
      translateFromDomToSvgCoordinates: zo,
      translateFromSvgToDomCoordinates: To,
      getAsSvg: _o,
      exportAsSvgText: Io,
      exportAsSvgElement: sn
    });
    function $o(P, Z, A, V) {
      P.setZoomEnabled(Z), Z && A ? P.enableDblClickZoom() : P.disableDblClickZoom(), Z && V ? P.enableMouseWheelZoom() : P.disableMouseWheelZoom();
    }
    function rn(P) {
      return P.zoomEnabled && P.doubleClickZoomEnabled;
    }
    function Pt(P) {
      return P.zoomEnabled && P.mouseWheelZoomEnabled;
    }
    function an(P) {
      P.stopPropagation();
    }
    return (P, Z) => (S(), I("div", {
      ref_key: "container",
      ref: v,
      class: "v-network-graph v-ng-container"
    }, [
      (S(), I("svg", {
        ref_key: "svg",
        ref: b,
        class: he(["v-ng-canvas", { show: f.value, dragging: xt.value, touches: ho.value, "box-selection-mode": M(bo) }]),
        width: "100%",
        height: "100%"
      }, [
        (S(!0), I(G, null, J(p.value.root, (A) => Y(P.$slots, A, {
          key: A,
          scale: M(N)
        })), 128)),
        Object.keys(M(kt).markers).length > 0 ? (S(), I("defs", Rr, [
          (S(!0), I(G, null, J(M(kt).markers, (A, V) => (S(), W(qs, {
            id: V,
            key: V,
            marker: A,
            scale: M(N)
          }, null, 8, ["id", "marker", "scale"]))), 128))
        ])) : ue("", !0),
        k.value ? (S(), W(tr, { key: 1 }, {
          default: ne(() => [
            (S(!0), I(G, null, J(p.value.background, (A) => (S(), I("g", {
              key: A,
              class: "v-ng-layer"
            }, [
              Y(P.$slots, A, { scale: M(N) })
            ]))), 128)),
            w.value ? (S(), W(er, { key: 0 })) : ue("", !0),
            (S(!0), I(G, null, J(p.value.grid, (A) => (S(), I("g", {
              key: A,
              class: "v-ng-layer"
            }, [
              Y(P.$slots, A, { scale: M(N) })
            ]))), 128))
          ]),
          _: 3
        })) : ue("", !0),
        Tn("g", {
          ref_key: "viewport",
          ref: E,
          class: he(["v-ng-viewport", { "v-ng-transition": M(on).enabled }]),
          style: tt(ko.value)
        }, [
          (S(!0), I(G, null, J(p.value.base, (A) => (S(), I("g", {
            key: A,
            class: "v-ng-layer"
          }, [
            Y(P.$slots, A, { scale: M(N) })
          ]))), 128)),
          (S(!0), I(G, null, J(M(y), (A) => (S(), I(G, { key: A }, [
            A === "edges" ? (S(), W(wr, { key: 0 }, Bt({ _: 2 }, [
              "edge-overlay" in M(r) ? {
                name: "edge-overlay",
                fn: ne((V) => [
                  Y(P.$slots, "edge-overlay", oe({ ref_for: !0 }, V))
                ]),
                key: "0"
              } : void 0
            ]), 1024)) : A === "edge-labels" ? (S(), W(Sr, {
              key: 1,
              "enable-edge-label": "edge-label" in M(r),
              "enable-edges-label": "edges-label" in M(r)
            }, {
              "edge-label": ne((V) => [
                Y(P.$slots, "edge-label", oe({ ref_for: !0 }, V))
              ]),
              "edges-label": ne((V) => [
                Y(P.$slots, "edges-label", oe({ ref_for: !0 }, V))
              ]),
              _: 3
            }, 8, ["enable-edge-label", "enable-edges-label"])) : A === "focusring" ? (S(), W(Or, { key: 2 })) : A === "nodes" ? (S(), W(Tr, { key: 3 }, {
              "override-node": ne((V) => [
                Y(P.$slots, "override-node", oe({ ref_for: !0 }, V))
              ]),
              _: 3
            })) : A === "node-labels" ? (S(), W(Zr, { key: 4 }, {
              "override-node-label": ne((V) => [
                Y(P.$slots, "override-node-label", oe({ ref_for: !0 }, V))
              ]),
              _: 3
            })) : A === "paths" ? (S(), W(Br, { key: 5 })) : ue("", !0),
            (S(!0), I(G, null, J(p.value[A], (V) => (S(), I("g", {
              key: V,
              class: "v-ng-layer"
            }, [
              Y(P.$slots, V, { scale: M(N) })
            ]))), 128))
          ], 64))), 128))
        ], 6),
        M(tn) ? (S(), W(Bs, {
          key: 2,
          box: M(tn),
          config: M(l).view.selection.box
        }, null, 8, ["box", "config"])) : ue("", !0)
      ], 2))
    ], 512));
  }
}), Wr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, i] of t)
    n[o] = i;
  return n;
}, Hr = {};
function Fr(e, t) {
  return S(), I("defs", null, [
    (S(), W(zn("style"), null, {
      default: ne(() => [
        Y(e.$slots, "default")
      ]),
      _: 3
    }))
  ]);
}
const Ur = /* @__PURE__ */ Wr(Hr, [["render", Fr]]), Xr = /* @__PURE__ */ F({
  __name: "VEdgeLabel",
  props: {
    area: {},
    config: {},
    text: { default: "" },
    align: { default: "center" },
    verticalAlign: { default: "center" },
    edge: { default: void 0 },
    hovered: { type: Boolean, default: void 0 },
    selected: { type: Boolean, default: void 0 },
    scale: { default: void 0 }
  },
  setup(e) {
    const t = e, n = j(0), o = j(0), i = j("middle"), s = j("central"), r = j(0);
    ve(() => {
      const c = t.area.source, d = t.area.target;
      t.align === "source" ? (c.above.x == d.above.x ? i.value = c.above.y > d.above.y ? "start" : "end" : i.value = c.above.x < d.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = c.above.x, o.value = c.above.y, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = c.below.x, o.value = c.below.y, s.value = "hanging") : (n.value = (c.above.x + c.below.x) / 2, o.value = (c.above.y + c.below.y) / 2, s.value = "central")) : t.align === "target" ? (c.above.x == d.above.x ? i.value = c.above.y < d.above.y ? "start" : "end" : i.value = c.above.x > d.above.x ? "start" : "end", t.verticalAlign === "above" ? (n.value = d.above.x, o.value = d.above.y, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = d.below.x, o.value = d.below.y, s.value = "hanging") : (n.value = (d.above.x + d.below.x) / 2, o.value = (d.above.y + d.below.y) / 2, s.value = "central")) : (i.value = "middle", t.verticalAlign === "above" ? (n.value = (c.above.x + d.above.x) / 2, o.value = (c.above.y + d.above.y) / 2, s.value = "text-top") : t.verticalAlign === "below" ? (n.value = (c.below.x + d.below.x) / 2, o.value = (c.below.y + d.below.y) / 2, s.value = "hanging") : (n.value = (c.above.x + d.below.x) / 2, o.value = (c.above.y + d.below.y) / 2, s.value = "central"));
      let u = Q.fromPositions(c.above, d.above).v.angleDegree();
      (u < -90 || u >= 90) && (u = u + 180, u > 180 && (u -= 360)), r.value = u;
    });
    const a = O(() => s.value === "central" && !t.config.background ? Xe(se({}, t.config), {
      background: {
        visible: !0,
        color: "#ffffff",
        padding: {
          vertical: 1,
          horizontal: 4
        },
        borderRadius: 2
      }
    }) : t.config);
    return (c, d) => (S(), W(Et, {
      class: "v-ng-edge-label",
      text: c.text,
      x: n.value,
      y: o.value,
      config: a.value,
      "text-anchor": i.value,
      "dominant-baseline": s.value,
      transform: `rotate(${r.value} ${n.value} ${o.value})`
    }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]));
  }
}), qr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VEdgeLabel: Xr,
  VLabelText: Et,
  VNetworkGraph: Vr,
  VShape: wt,
  VStyle: Ur
}, Symbol.toStringTag, { value: "Module" })), Gr = 10;
class na extends $n {
  constructor(t = {}) {
    super(), this.options = t;
  }
  setNodePosition(t, n) {
    const o = this.options.grid || Gr;
    t.value.x = Math.floor(n.x / o) * o, t.value.y = Math.floor(n.y / o) * o;
  }
}
const oa = function(e) {
  Object.entries(qr).forEach(([t, n]) => {
    e.component(t, n);
  });
};
export {
  _ as Config,
  na as GridLayout,
  Xo as LayerPositions,
  D as NodeLabelDirection,
  $n as SimpleLayout,
  Xr as VEdgeLabel,
  Et as VLabelText,
  Vr as VNetworkGraph,
  wt as VShape,
  Ur as VStyle,
  R as Vector2D,
  Jr as configsWithType,
  oa as default,
  ea as defineConfigs,
  ta as getFullConfigs,
  ke as useStates,
  Mt as withSelf
};
//# sourceMappingURL=index.js.map
